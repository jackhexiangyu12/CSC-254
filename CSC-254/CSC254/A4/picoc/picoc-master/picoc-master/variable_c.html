<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head>
<body><pre><a name="1">/* picoc variable storage. This provides ways of defining and accessing</a>
<a name="2"> * variables */</a>
<a name="3"> </a>
<a name="4">#include "interpreter.h"</a>
<a name="5"></a>
<a name="6">/* maximum size of a value to temporarily copy while we create a variable */</a>
<a name="7">#define MAX_TMP_COPY_BUF 256</a>
<a name="8"></a>
<a name="9"></a>
<a name="10">/* initialise the variable system */</a>
<a name="11">void <a name="searched">VariableInit</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="12">{</a>
<a name="13">    <a href="table_c.html#32">TableInitTable</a>(&(<a href="variable_c.html#11">pc</a>-&gtGlobalTable), &(<a href="variable_c.html#11">pc</a>-&gtGlobalHashTable)[0], GLOBAL_TABLE_SIZE, TRUE);</a>
<a name="14">    <a href="table_c.html#32">TableInitTable</a>(&<a href="variable_c.html#11">pc</a>-&gtStringLiteralTable, &<a href="variable_c.html#11">pc</a>-&gtStringLiteralHashTable[0], STRING_LITERAL_TABLE_SIZE, TRUE);</a>
<a name="15">    <a href="variable_c.html#11">pc</a>-&gtTopStackFrame = NULL;</a>
<a name="16">}</a>
<a name="17"></a>
<a name="18">/* deallocate the contents of a variable */</a>
<a name="19">void <a name="searched">VariableFree</a>(Picoc *<a name="searched">pc</a>, struct <a name="searched">Val</a>ue *<a name="searched">Val</a>)</a>
<a name="20">{</a>
<a name="21">    if (<a href="variable_c.html#19">Val</a>-&gtValOnHeap || <a href="variable_c.html#19">Val</a>-&gtAnyValOnHeap)</a>
<a name="22">    {</a>
<a name="23">        /* free function bodies */</a>
<a name="24">        if (<a href="variable_c.html#19">Val</a>-&gtTyp == &<a href="variable_c.html#19">pc</a>-&gtFunctionType && <a href="variable_c.html#19">Val</a>-&gtVal-&gtFuncDef.Intrinsic == NULL && <a href="variable_c.html#19">Val</a>-&gtVal-&gtFuncDef.Body.Pos != NULL)</a>
<a name="25">            <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#19">pc</a>, (void *)<a href="variable_c.html#19">Val</a>-&gtVal-&gtFuncDef.Body.Pos);</a>
<a name="26"></a>
<a name="27">        /* free macro bodies */</a>
<a name="28">        if (<a href="variable_c.html#19">Val</a>-&gtTyp == &<a href="variable_c.html#19">pc</a>-&gtMacroType)</a>
<a name="29">            <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#19">pc</a>, (void *)<a href="variable_c.html#19">Val</a>-&gtVal-&gtMacroDef.Body.Pos);</a>
<a name="30"></a>
<a name="31">        /* free the AnyValue */</a>
<a name="32">        if (<a href="variable_c.html#19">Val</a>-&gtAnyValOnHeap)</a>
<a name="33">            <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#19">pc</a>, <a href="variable_c.html#19">Val</a>-&gtVal);</a>
<a name="34">    }</a>
<a name="35"></a>
<a name="36">    /* free the value */</a>
<a name="37">    if (<a href="variable_c.html#19">Val</a>-&gtValOnHeap)</a>
<a name="38">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#19">pc</a>, <a href="variable_c.html#19">Val</a>);</a>
<a name="39">}</a>
<a name="40"></a>
<a name="41">/* deallocate the global table and the string literal table */</a>
<a name="42">void <a name="searched">VariableTableCleanup</a>(Picoc *<a name="searched">pc</a>, struct Table *<a name="searched">HashTable</a>)</a>
<a name="43">{</a>
<a name="44">    struct Table<a name="searched">Entry</a> *<a name="searched">Entry</a>;</a>
<a name="45">    struct TableEntry *<a name="searched">NextEntry</a>;</a>
<a name="46">    int <a name="searched">Count</a>;</a>
<a name="47">    </a>
<a name="48">    for (<a href="variable_c.html#46">Count</a> = 0; <a href="variable_c.html#46">Count</a> &lt <a href="variable_c.html#42">HashTable</a>-&gtSize; <a href="variable_c.html#46">Count</a>++)</a>
<a name="49">    {</a>
<a name="50">        for (<a href="variable_c.html#44">Entry</a> = <a href="variable_c.html#42">HashTable</a>-&gtHashTable[<a href="variable_c.html#46">Count</a>]; <a href="variable_c.html#44">Entry</a> != NULL; <a href="variable_c.html#44">Entry</a> = <a href="variable_c.html#45">NextEntry</a>)</a>
<a name="51">        {</a>
<a name="52">            <a href="variable_c.html#45">NextEntry</a> = <a href="variable_c.html#44">Entry</a>-&gtNext;</a>
<a name="53">            <a href="variable_c.html#19">VariableFree</a>(<a href="variable_c.html#42">pc</a>, <a href="variable_c.html#44">Entry</a>-&gtp.v.Val);</a>
<a name="54">                </a>
<a name="55">            /* free the hash table entry */</a>
<a name="56">            <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#42">pc</a>, <a href="variable_c.html#44">Entry</a>);</a>
<a name="57">        }</a>
<a name="58">    }</a>
<a name="59">}</a>
<a name="60"></a>
<a name="61">void <a name="searched">VariableCleanup</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="62">{</a>
<a name="63">    <a href="variable_c.html#42">VariableTableCleanup</a>(<a href="variable_c.html#61">pc</a>, &<a href="variable_c.html#61">pc</a>-&gtGlobalTable);</a>
<a name="64">    <a href="variable_c.html#42">VariableTableCleanup</a>(<a href="variable_c.html#61">pc</a>, &<a href="variable_c.html#61">pc</a>-&gtStringLiteralTable);</a>
<a name="65">}</a>
<a name="66"></a>
<a name="67">/* allocate some memory, either on the heap or the stack and check if we've run out */</a>
<a name="68">void *<a name="searched">VariableAlloc</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, int <a name="searched">Size</a>, int <a name="searched">OnHeap</a>)</a>
<a name="69">{</a>
<a name="70">    void *<a name="searched">NewValue</a>;</a>
<a name="71">    </a>
<a name="72">    if (<a href="variable_c.html#68">OnHeap</a>)</a>
<a name="73">        <a href="variable_c.html#70">NewValue</a> = <a href="heap_c.html#135">HeapAllocMem</a>(<a href="variable_c.html#68">pc</a>, <a href="variable_c.html#68">Size</a>);</a>
<a name="74">    else</a>
<a name="75">        <a href="variable_c.html#70">NewValue</a> = <a href="heap_c.html#67">HeapAllocStack</a>(<a href="variable_c.html#68">pc</a>, <a href="variable_c.html#68">Size</a>);</a>
<a name="76">    </a>
<a name="77">    if (<a href="variable_c.html#70">NewValue</a> == NULL)</a>
<a name="78">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#68">Parser</a>, "out of memory");</a>
<a name="79">    </a>
<a name="80">#ifdef DEBUG_HEAP</a>
<a name="81">    if (!<a href="variable_c.html#68">OnHeap</a>)</a>
<a name="82">        printf("pushing %d at 0x%lx\n", <a href="variable_c.html#68">Size</a>, (unsigned long)<a href="variable_c.html#70">NewValue</a>);</a>
<a name="83">#endif</a>
<a name="84">        </a>
<a name="85">    return <a href="variable_c.html#70">NewValue</a>;</a>
<a name="86">}</a>
<a name="87"></a>
<a name="88">/* allocate a value either on the heap or the stack using space dependent on what type we want */</a>
<a name="89">struct Value *<a name="searched">VariableAllocValueAndData</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, int <a name="searched">DataSize</a>, int <a name="searched">IsLValue</a>, struct Value *<a name="searched">LValueFrom</a>, int <a name="searched">OnHeap</a>)</a>
<a name="90">{</a>
<a name="91">    struct Value *<a name="searched">NewValue</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="variable_c.html#89">pc</a>, <a href="variable_c.html#89">Parser</a>, MEM_ALIGN(sizeof(struct Value)) + <a href="variable_c.html#89">DataSize</a>, <a href="variable_c.html#89">OnHeap</a>);</a>
<a name="92">    <a href="variable_c.html#91">NewValue</a>-&gtVal = (union AnyValue *)((char *)<a href="variable_c.html#91">NewValue</a> + MEM_ALIGN(sizeof(struct Value)));</a>
<a name="93">    <a href="variable_c.html#91">NewValue</a>-&gtValOnHeap = <a href="variable_c.html#89">OnHeap</a>;</a>
<a name="94">    <a href="variable_c.html#91">NewValue</a>-&gtAnyValOnHeap = FALSE;</a>
<a name="95">    <a href="variable_c.html#91">NewValue</a>-&gtValOnStack = !<a href="variable_c.html#89">OnHeap</a>;</a>
<a name="96">    <a href="variable_c.html#91">NewValue</a>-&gtIsLValue = <a href="variable_c.html#89">IsLValue</a>;</a>
<a name="97">    <a href="variable_c.html#91">NewValue</a>-&gtLValueFrom = <a href="variable_c.html#89">LValueFrom</a>;</a>
<a name="98">    if (<a href="variable_c.html#89">Parser</a>) </a>
<a name="99">        <a href="variable_c.html#91">NewValue</a>-&gtScopeID = <a href="variable_c.html#89">Parser</a>-&gtScopeID;</a>
<a name="100"></a>
<a name="101">    <a href="variable_c.html#91">NewValue</a>-&gtOutOfScope = 0;</a>
<a name="102">    </a>
<a name="103">    return <a href="variable_c.html#91">NewValue</a>;</a>
<a name="104">}</a>
<a name="105"></a>
<a name="106">/* allocate a value given its type */</a>
<a name="107">struct Value *VariableAllocValueFrom<a name="searched">Typ</a>e(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, int <a name="searched">IsLValue</a>, struct Value *<a name="searched">LValueFrom</a>, int <a name="searched">OnHeap</a>)</a>
<a name="108">{</a>
<a name="109">    int <a name="searched">Size</a> = Type<a name="searched">Size</a>(<a href="variable_c.html#107">Typ</a>, <a href="variable_c.html#107">Typ</a>-&gtArray<a name="searched">Size</a>, FALSE);</a>
<a name="110">    struct Value *<a name="searched">NewValue</a> = <a href="variable_c.html#89">VariableAllocValueAndData</a>(<a href="variable_c.html#107">pc</a>, <a href="variable_c.html#107">Parser</a>, <a href="variable_c.html#109">Size</a>, <a href="variable_c.html#107">IsLValue</a>, <a href="variable_c.html#107">LValueFrom</a>, <a href="variable_c.html#107">OnHeap</a>);</a>
<a name="111">    assert(<a href="variable_c.html#109">Size</a> &gt= 0 || <a href="variable_c.html#107">Typ</a> == &<a href="variable_c.html#107">pc</a>-&gtVoidType);</a>
<a name="112">    <a href="variable_c.html#110">NewValue</a>-&gtTyp = <a href="variable_c.html#107">Typ</a>;</a>
<a name="113">    </a>
<a name="114">    return <a href="variable_c.html#110">NewValue</a>;</a>
<a name="115">}</a>
<a name="116"></a>
<a name="117">/* allocate a value either on the heap or the stack and copy its value. handles overlapping data */</a>
<a name="118">struct Value *<a name="searched">VariableAllocValueAndCopy</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, struct Value *<a name="searched">FromValue</a>, int <a name="searched">OnHeap</a>)</a>
<a name="119">{</a>
<a name="120">    struct ValueType *<a name="searched">DType</a> = <a href="variable_c.html#118">FromValue</a>-&gtTyp;</a>
<a name="121">    struct Value *<a name="searched">NewValue</a>;</a>
<a name="122">    char <a name="searched">TmpBuf</a>[MAX_TMP_COPY_BUF];</a>
<a name="123">    int <a name="searched">CopySize</a> = <a href="type_c.html#69">TypeSizeValue</a>(<a href="variable_c.html#118">FromValue</a>, TRUE);</a>
<a name="124"></a>
<a name="125">    assert(<a href="variable_c.html#123">CopySize</a> &lt= MAX_TMP_COPY_BUF);</a>
<a name="126">    memcpy((void *)&<a href="variable_c.html#122">TmpBuf</a>[0], (void *)<a href="variable_c.html#118">FromValue</a>-&gtVal, <a href="variable_c.html#123">CopySize</a>);</a>
<a name="127">    <a href="variable_c.html#121">NewValue</a> = <a href="variable_c.html#89">VariableAllocValueAndData</a>(<a href="variable_c.html#118">pc</a>, <a href="variable_c.html#118">Parser</a>, <a href="variable_c.html#123">CopySize</a>, <a href="variable_c.html#118">FromValue</a>-&gtIsLValue, <a href="variable_c.html#118">FromValue</a>-&gtLValueFrom, <a href="variable_c.html#118">OnHeap</a>);</a>
<a name="128">    <a href="variable_c.html#121">NewValue</a>-&gtTyp = <a href="variable_c.html#120">DType</a>;</a>
<a name="129">    memcpy((void *)<a href="variable_c.html#121">NewValue</a>-&gtVal, (void *)&<a href="variable_c.html#122">TmpBuf</a>[0], <a href="variable_c.html#123">CopySize</a>);</a>
<a name="130">    </a>
<a name="131">    return <a href="variable_c.html#121">NewValue</a>;</a>
<a name="132">}</a>
<a name="133"></a>
<a name="134">/* allocate a value either on the heap or the stack from an existing AnyValue and type */</a>
<a name="135">struct Value *<a name="searched">VariableAllocValueFromExistingData</a>(struct ParseState *<a name="searched">Parser</a>, struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, union AnyValue *<a name="searched">FromValue</a>, int <a name="searched">IsLValue</a>, struct Value *<a name="searched">LValueFrom</a>)</a>
<a name="136">{</a>
<a name="137">    struct Value *<a name="searched">NewValue</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="variable_c.html#135">Parser</a>-&gtpc, <a href="variable_c.html#135">Parser</a>, sizeof(struct Value), FALSE);</a>
<a name="138">    <a href="variable_c.html#137">NewValue</a>-&gtTyp = <a href="variable_c.html#135">Typ</a>;</a>
<a name="139">    <a href="variable_c.html#137">NewValue</a>-&gtVal = <a href="variable_c.html#135">FromValue</a>;</a>
<a name="140">    <a href="variable_c.html#137">NewValue</a>-&gtValOnHeap = FALSE;</a>
<a name="141">    <a href="variable_c.html#137">NewValue</a>-&gtAnyValOnHeap = FALSE;</a>
<a name="142">    <a href="variable_c.html#137">NewValue</a>-&gtValOnStack = FALSE;</a>
<a name="143">    <a href="variable_c.html#137">NewValue</a>-&gtIsLValue = <a href="variable_c.html#135">IsLValue</a>;</a>
<a name="144">    <a href="variable_c.html#137">NewValue</a>-&gtLValueFrom = <a href="variable_c.html#135">LValueFrom</a>;</a>
<a name="145">    </a>
<a name="146">    return <a href="variable_c.html#137">NewValue</a>;</a>
<a name="147">}</a>
<a name="148"></a>
<a name="149">/* allocate a value either on the heap or the stack from an existing Value, sharing the value */</a>
<a name="150">struct Value *<a name="searched">VariableAllocValueShared</a>(struct ParseState *<a name="searched">Parser</a>, struct Value *<a name="searched">FromValue</a>)</a>
<a name="151">{</a>
<a name="152">    return <a href="variable_c.html#135">VariableAllocValueFromExistingData</a>(<a href="variable_c.html#150">Parser</a>, <a href="variable_c.html#150">FromValue</a>-&gtTyp, <a href="variable_c.html#150">FromValue</a>-&gtVal, <a href="variable_c.html#150">FromValue</a>-&gtIsLValue, <a href="variable_c.html#150">FromValue</a>-&gtIsLValue ? <a href="variable_c.html#150">FromValue</a> : NULL);</a>
<a name="153">}</a>
<a name="154"></a>
<a name="155">/* reallocate a variable so its data has a new size */</a>
<a name="156">void <a name="searched">VariableRealloc</a>(struct ParseState *<a name="searched">Parser</a>, struct Value *<a name="searched">FromValue</a>, int <a name="searched">NewSize</a>)</a>
<a name="157">{</a>
<a name="158">    if (<a href="variable_c.html#156">FromValue</a>-&gtAnyValOnHeap)</a>
<a name="159">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#156">Parser</a>-&gtpc, <a href="variable_c.html#156">FromValue</a>-&gtVal);</a>
<a name="160">        </a>
<a name="161">    <a href="variable_c.html#156">FromValue</a>-&gtVal = <a href="variable_c.html#68">VariableAlloc</a>(<a href="variable_c.html#156">Parser</a>-&gtpc, <a href="variable_c.html#156">Parser</a>, <a href="variable_c.html#156">NewSize</a>, TRUE);</a>
<a name="162">    <a href="variable_c.html#156">FromValue</a>-&gtAnyValOnHeap = TRUE;</a>
<a name="163">}</a>
<a name="164"></a>
<a name="165">int <a name="searched">VariableScopeBegin</a>(struct ParseState * <a name="searched">Parser</a>, int* <a name="searched">OldScopeID</a>)</a>
<a name="166">{</a>
<a name="167">    struct Table<a name="searched">Entry</a> *<a name="searched">Entry</a>;</a>
<a name="168">    struct TableEntry *<a name="searched">NextEntry</a>;</a>
<a name="169">    Picoc * <a name="searched">pc</a> = <a href="variable_c.html#165">Parser</a>-&gt<a name="searched">pc</a>;</a>
<a name="170">    int <a name="searched">Count</a>;</a>
<a name="171">    #ifdef VAR_SCOPE_DEBUG</a>
<a name="172">    int FirstPrint = 0;</a>
<a name="173">    #endif</a>
<a name="174">    </a>
<a name="175">    struct Table * <a name="searched">HashTable</a> = (<a href="variable_c.html#169">pc</a>-&gtTopStackFrame == NULL) ? &(<a href="variable_c.html#169">pc</a>-&gtGlobalTable) : &(<a href="variable_c.html#169">pc</a>-&gtTopStackFrame)-&gtLocalTable;</a>
<a name="176"></a>
<a name="177">    if (<a href="variable_c.html#165">Parser</a>-&gtScopeID == -1) return -1;</a>
<a name="178"></a>
<a name="179">    /* XXX dumb hash, let's hope for no collisions... */</a>
<a name="180">    *<a href="variable_c.html#165">OldScopeID</a> = <a href="variable_c.html#165">Parser</a>-&gtScopeID;</a>
<a name="181">    <a href="variable_c.html#165">Parser</a>-&gtScopeID = (int)(intptr_t)(<a href="variable_c.html#165">Parser</a>-&gtSourceText) * ((int)(intptr_t)(<a href="variable_c.html#165">Parser</a>-&gtPos) / sizeof(char*));</a>
<a name="182">    /* or maybe a more human-readable hash for debugging? */</a>
<a name="183">    /* <a href="variable_c.html#165">Parser</a>-&gtScopeID = <a href="variable_c.html#165">Parser</a>-&gtLine * 0x10000 + <a href="variable_c.html#165">Parser</a>-&gtCharacterPos; */</a>
<a name="184">    </a>
<a name="185">    for (<a href="variable_c.html#170">Count</a> = 0; <a href="variable_c.html#170">Count</a> &lt <a href="variable_c.html#175">HashTable</a>-&gtSize; <a href="variable_c.html#170">Count</a>++)</a>
<a name="186">    {</a>
<a name="187">        for (<a href="variable_c.html#167">Entry</a> = <a href="variable_c.html#175">HashTable</a>-&gtHashTable[<a href="variable_c.html#170">Count</a>]; <a href="variable_c.html#167">Entry</a> != NULL; <a href="variable_c.html#167">Entry</a> = <a href="variable_c.html#168">NextEntry</a>)</a>
<a name="188">        {</a>
<a name="189">            <a href="variable_c.html#168">NextEntry</a> = <a href="variable_c.html#167">Entry</a>-&gtNext;</a>
<a name="190">            if (<a href="variable_c.html#167">Entry</a>-&gtp.v.Val-&gtScopeID == <a href="variable_c.html#165">Parser</a>-&gtScopeID && <a href="variable_c.html#167">Entry</a>-&gtp.v.Val-&gtOutOfScope)</a>
<a name="191">            {</a>
<a name="192">                <a href="variable_c.html#167">Entry</a>-&gtp.v.Val-&gtOutOfScope = FALSE;</a>
<a name="193">                <a href="variable_c.html#167">Entry</a>-&gtp.v.Key = (char*)((intptr_t)<a href="variable_c.html#167">Entry</a>-&gtp.v.Key & ~1);</a>
<a name="194">                #ifdef VAR_SCOPE_DEBUG</a>
<a name="195">                if (!FirstPrint) { PRINT_SOURCE_POS; }</a>
<a name="196">                FirstPrint = 1;</a>
<a name="197">                printf("&gt&gt&gt back into scope: %s %x %d\n", <a href="variable_c.html#167">Entry</a>-&gtp.v.Key, <a href="variable_c.html#167">Entry</a>-&gtp.v.Val-&gtScopeID, <a href="variable_c.html#167">Entry</a>-&gtp.v.Val-&gtVal-&gtInteger);</a>
<a name="198">                #endif</a>
<a name="199">            }</a>
<a name="200">        }</a>
<a name="201">    }</a>
<a name="202"></a>
<a name="203">    return <a href="variable_c.html#165">Parser</a>-&gtScopeID;</a>
<a name="204">}</a>
<a name="205"></a>
<a name="206">void <a name="searched">VariableScopeEnd</a>(struct ParseState * <a name="searched">Parser</a>, int <a name="searched">ScopeID</a>, int Prev<a name="searched">ScopeID</a>)</a>
<a name="207">{</a>
<a name="208">    struct Table<a name="searched">Entry</a> *<a name="searched">Entry</a>;</a>
<a name="209">    struct TableEntry *<a name="searched">NextEntry</a>;</a>
<a name="210">    Picoc * <a name="searched">pc</a> = <a href="variable_c.html#206">Parser</a>-&gt<a name="searched">pc</a>;</a>
<a name="211">    int <a name="searched">Count</a>;</a>
<a name="212">    #ifdef VAR_SCOPE_DEBUG</a>
<a name="213">    int FirstPrint = 0;</a>
<a name="214">    #endif</a>
<a name="215"></a>
<a name="216">    struct Table * <a name="searched">HashTable</a> = (<a href="variable_c.html#210">pc</a>-&gtTopStackFrame == NULL) ? &(<a href="variable_c.html#210">pc</a>-&gtGlobalTable) : &(<a href="variable_c.html#210">pc</a>-&gtTopStackFrame)-&gtLocalTable;</a>
<a name="217"></a>
<a name="218">    if (<a href="variable_c.html#206">ScopeID</a> == -1) return;</a>
<a name="219"></a>
<a name="220">    for (<a href="variable_c.html#211">Count</a> = 0; <a href="variable_c.html#211">Count</a> &lt <a href="variable_c.html#216">HashTable</a>-&gtSize; <a href="variable_c.html#211">Count</a>++)</a>
<a name="221">    {</a>
<a name="222">        for (<a href="variable_c.html#208">Entry</a> = <a href="variable_c.html#216">HashTable</a>-&gtHashTable[<a href="variable_c.html#211">Count</a>]; <a href="variable_c.html#208">Entry</a> != NULL; <a href="variable_c.html#208">Entry</a> = <a href="variable_c.html#209">NextEntry</a>)</a>
<a name="223">        {</a>
<a name="224">            <a href="variable_c.html#209">NextEntry</a> = <a href="variable_c.html#208">Entry</a>-&gtNext;</a>
<a name="225">            if (<a href="variable_c.html#208">Entry</a>-&gtp.v.Val-&gtScopeID == <a href="variable_c.html#206">ScopeID</a> && !<a href="variable_c.html#208">Entry</a>-&gtp.v.Val-&gtOutOfScope)</a>
<a name="226">            {</a>
<a name="227">                #ifdef VAR_SCOPE_DEBUG</a>
<a name="228">                if (!FirstPrint) { PRINT_SOURCE_POS; }</a>
<a name="229">                FirstPrint = 1;</a>
<a name="230">                printf("&gt&gt&gt out of scope: %s %x %d\n", <a href="variable_c.html#208">Entry</a>-&gtp.v.Key, <a href="variable_c.html#208">Entry</a>-&gtp.v.Val-&gtScopeID, <a href="variable_c.html#208">Entry</a>-&gtp.v.Val-&gtVal-&gtInteger);</a>
<a name="231">                #endif</a>
<a name="232">                <a href="variable_c.html#208">Entry</a>-&gtp.v.Val-&gtOutOfScope = TRUE;</a>
<a name="233">                <a href="variable_c.html#208">Entry</a>-&gtp.v.Key = (char*)((intptr_t)<a href="variable_c.html#208">Entry</a>-&gtp.v.Key | 1); /* alter the key so it won't be found by normal searches */</a>
<a name="234">            }</a>
<a name="235">        }</a>
<a name="236">    }</a>
<a name="237"></a>
<a name="238">    <a href="variable_c.html#206">Parser</a>-&gtScopeID = <a href="variable_c.html#206">PrevScopeID</a>;</a>
<a name="239">}</a>
<a name="240"></a>
<a name="241">int <a name="searched">VariableDefinedAndOutOfScope</a>(Picoc * <a name="searched">pc</a>, const char* <a name="searched">Ident</a>)</a>
<a name="242">{</a>
<a name="243">    struct Table<a name="searched">Entry</a> *<a name="searched">Entry</a>;</a>
<a name="244">    int <a name="searched">Count</a>;</a>
<a name="245"></a>
<a name="246">    struct Table * <a name="searched">HashTable</a> = (<a href="variable_c.html#241">pc</a>-&gtTopStackFrame == NULL) ? &(<a href="variable_c.html#241">pc</a>-&gtGlobalTable) : &(<a href="variable_c.html#241">pc</a>-&gtTopStackFrame)-&gtLocalTable;</a>
<a name="247">    for (<a href="variable_c.html#244">Count</a> = 0; <a href="variable_c.html#244">Count</a> &lt <a href="variable_c.html#246">HashTable</a>-&gtSize; <a href="variable_c.html#244">Count</a>++)</a>
<a name="248">    {</a>
<a name="249">        for (<a href="variable_c.html#243">Entry</a> = <a href="variable_c.html#246">HashTable</a>-&gtHashTable[<a href="variable_c.html#244">Count</a>]; <a href="variable_c.html#243">Entry</a> != NULL; <a href="variable_c.html#243">Entry</a> = <a href="variable_c.html#243">Entry</a>-&gtNext)</a>
<a name="250">        {</a>
<a name="251">            if (<a href="variable_c.html#243">Entry</a>-&gtp.v.Val-&gtOutOfScope && (char*)((intptr_t)<a href="variable_c.html#243">Entry</a>-&gtp.v.Key & ~1) == <a href="variable_c.html#241">Ident</a>)</a>
<a name="252">                return TRUE;</a>
<a name="253">        }</a>
<a name="254">    }</a>
<a name="255">    return FALSE;</a>
<a name="256">}</a>
<a name="257"></a>
<a name="258">/* define a variable. Ident must be registered */</a>
<a name="259">struct Value *<a name="searched">VariableDefine</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, char *<a name="searched">Ident</a>, struct Value *<a name="searched">InitValue</a>, struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, int <a name="searched">MakeWritable</a>)</a>
<a name="260">{</a>
<a name="261">    struct Value * <a name="searched">AssignValue</a>;</a>
<a name="262">    struct Table * <a name="searched">currentTable</a> = (<a href="variable_c.html#259">pc</a>-&gtTopStackFrame == NULL) ? &(<a href="variable_c.html#259">pc</a>-&gtGlobalTable) : &(<a href="variable_c.html#259">pc</a>-&gtTopStackFrame)-&gtLocalTable;</a>
<a name="263">    </a>
<a name="264">    int <a name="searched">ScopeID</a> = <a href="variable_c.html#259">Parser</a> ? <a href="variable_c.html#259">Parser</a>-&gt<a name="searched">ScopeID</a> : -1;</a>
<a name="265">#ifdef VAR_SCOPE_DEBUG</a>
<a name="266">    if (<a href="variable_c.html#259">Parser</a>) fprintf(stderr, "def %s %x (%s:%d:%d)\n", <a href="variable_c.html#259">Ident</a>, <a href="variable_c.html#264">ScopeID</a>, <a href="variable_c.html#259">Parser</a>-&gtFileName, <a href="variable_c.html#259">Parser</a>-&gtLine, <a href="variable_c.html#259">Parser</a>-&gtCharacterPos);</a>
<a name="267">#endif</a>
<a name="268">    </a>
<a name="269">    if (<a href="variable_c.html#259">InitValue</a> != NULL)</a>
<a name="270">        <a href="variable_c.html#261">AssignValue</a> = <a href="variable_c.html#118">VariableAllocValueAndCopy</a>(<a href="variable_c.html#259">pc</a>, <a href="variable_c.html#259">Parser</a>, <a href="variable_c.html#259">InitValue</a>, <a href="variable_c.html#259">pc</a>-&gtTopStackFrame == NULL);</a>
<a name="271">    else</a>
<a name="272">        <a href="variable_c.html#261">AssignValue</a> = <a href="variable_c.html#107">VariableAllocValueFromType</a>(<a href="variable_c.html#259">pc</a>, <a href="variable_c.html#259">Parser</a>, <a href="variable_c.html#259">Typ</a>, <a href="variable_c.html#259">MakeWritable</a>, NULL, <a href="variable_c.html#259">pc</a>-&gtTopStackFrame == NULL);</a>
<a name="273">    </a>
<a name="274">    <a href="variable_c.html#261">AssignValue</a>-&gtIsLValue = <a href="variable_c.html#259">MakeWritable</a>;</a>
<a name="275">    <a href="variable_c.html#261">AssignValue</a>-&gtScopeID = <a href="variable_c.html#264">ScopeID</a>;</a>
<a name="276">    <a href="variable_c.html#261">AssignValue</a>-&gtOutOfScope = FALSE;</a>
<a name="277"></a>
<a name="278">    if (!<a href="table_c.html#58">TableSet</a>(<a href="variable_c.html#259">pc</a>, <a href="variable_c.html#262">currentTable</a>, <a href="variable_c.html#259">Ident</a>, <a href="variable_c.html#261">AssignValue</a>, <a href="variable_c.html#259">Parser</a> ? ((char *)<a href="variable_c.html#259">Parser</a>-&gtFileName) : NULL, <a href="variable_c.html#259">Parser</a> ? <a href="variable_c.html#259">Parser</a>-&gtLine : 0, <a href="variable_c.html#259">Parser</a> ? <a href="variable_c.html#259">Parser</a>-&gtCharacterPos : 0))</a>
<a name="279">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#259">Parser</a>, "'%s' is already defined", <a href="variable_c.html#259">Ident</a>);</a>
<a name="280">    </a>
<a name="281">    return <a href="variable_c.html#261">AssignValue</a>;</a>
<a name="282">}</a>
<a name="283"></a>
<a name="284">/* define a variable. Ident must be registered. If it's a redefinition from the same declaration don't throw an error */</a>
<a name="285">struct Value *VariableDefineButIgnore<a name="searched">Ident</a>ical(struct ParseState *<a name="searched">Parser</a>, char *<a name="searched">Ident</a>, struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, int <a name="searched">IsStatic</a>, int *<a name="searched">FirstVisit</a>)</a>
<a name="286">{</a>
<a name="287">    Picoc *<a name="searched">pc</a> = <a href="variable_c.html#285">Parser</a>-&gt<a name="searched">pc</a>;</a>
<a name="288">    struct Value *<a name="searched">ExistingValue</a>;</a>
<a name="289">    const char *<a name="searched">DeclFileName</a>;</a>
<a name="290">    int <a name="searched">DeclLine</a>;</a>
<a name="291">    int <a name="searched">DeclColumn</a>;</a>
<a name="292">    </a>
<a name="293">    /* is the type a forward declaration? */</a>
<a name="294">    if (<a href="type_c.html#535">TypeIsForwardDeclared</a>(<a href="variable_c.html#285">Parser</a>, <a href="variable_c.html#285">Typ</a>))</a>
<a name="295">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#285">Parser</a>, "type '%t' isn't defined", <a href="variable_c.html#285">Typ</a>);</a>
<a name="296"></a>
<a name="297">    if (<a href="variable_c.html#285">IsStatic</a>)</a>
<a name="298">    {</a>
<a name="299">        char <a name="searched">MangledName</a>[LINEBUFFER_MAX];</a>
<a name="300">        char *<a name="searched">MNPos</a> = &<a href="variable_c.html#299">MangledName</a>[0];</a>
<a name="301">        char *<a name="searched">MNEnd</a> = &<a href="variable_c.html#299">MangledName</a>[LINEBUFFER_MAX-1];</a>
<a name="302">        const char *<a name="searched">RegisteredMangledName</a>;</a>
<a name="303">        </a>
<a name="304">        /* make the mangled static name (avoiding using sprintf() to minimise library impact) */</a>
<a name="305">        memset((void *)&<a href="variable_c.html#299">MangledName</a>, '\0', sizeof(<a href="variable_c.html#299">MangledName</a>));</a>
<a name="306">        *<a href="variable_c.html#300">MNPos</a>++ = '/';</a>
<a name="307">        strncpy(<a href="variable_c.html#300">MNPos</a>, (char *)<a href="variable_c.html#285">Parser</a>-&gtFileName, <a href="variable_c.html#301">MNEnd</a> - <a href="variable_c.html#300">MNPos</a>);</a>
<a name="308">        <a href="variable_c.html#300">MNPos</a> += strlen(<a href="variable_c.html#300">MNPos</a>);</a>
<a name="309">        </a>
<a name="310">        if (<a href="variable_c.html#287">pc</a>-&gtTopStackFrame != NULL)</a>
<a name="311">        {</a>
<a name="312">            /* we're inside a function */</a>
<a name="313">            if (<a href="variable_c.html#301">MNEnd</a> - <a href="variable_c.html#300">MNPos</a> &gt 0) *<a href="variable_c.html#300">MNPos</a>++ = '/';</a>
<a name="314">            strncpy(<a href="variable_c.html#300">MNPos</a>, (char *)<a href="variable_c.html#287">pc</a>-&gtTopStackFrame-&gtFuncName, <a href="variable_c.html#301">MNEnd</a> - <a href="variable_c.html#300">MNPos</a>);</a>
<a name="315">            <a href="variable_c.html#300">MNPos</a> += strlen(<a href="variable_c.html#300">MNPos</a>);</a>
<a name="316">        }</a>
<a name="317">            </a>
<a name="318">        if (<a href="variable_c.html#301">MNEnd</a> - <a href="variable_c.html#300">MNPos</a> &gt 0) *<a href="variable_c.html#300">MNPos</a>++ = '/';</a>
<a name="319">        strncpy(<a href="variable_c.html#300">MNPos</a>, <a href="variable_c.html#285">Ident</a>, <a href="variable_c.html#301">MNEnd</a> - <a href="variable_c.html#300">MNPos</a>);</a>
<a name="320">        <a href="variable_c.html#302">RegisteredMangledName</a> = <a href="table_c.html#166">TableStrRegister</a>(<a href="variable_c.html#287">pc</a>, <a href="variable_c.html#299">MangledName</a>);</a>
<a name="321">        </a>
<a name="322">        /* is this static already defined? */</a>
<a name="323">        if (!<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#287">pc</a>-&gtGlobalTable, <a href="variable_c.html#302">RegisteredMangledName</a>, &<a href="variable_c.html#288">ExistingValue</a>, &<a href="variable_c.html#289">DeclFileName</a>, &<a href="variable_c.html#290">DeclLine</a>, &<a href="variable_c.html#291">DeclColumn</a>))</a>
<a name="324">        {</a>
<a name="325">            /* define the mangled-named static variable store in the global scope */</a>
<a name="326">            <a href="variable_c.html#288">ExistingValue</a> = <a href="variable_c.html#107">VariableAllocValueFromType</a>(<a href="variable_c.html#285">Parser</a>-&gtpc, <a href="variable_c.html#285">Parser</a>, <a href="variable_c.html#285">Typ</a>, TRUE, NULL, TRUE);</a>
<a name="327">            <a href="table_c.html#58">TableSet</a>(<a href="variable_c.html#287">pc</a>, &<a href="variable_c.html#287">pc</a>-&gtGlobalTable, (char *)<a href="variable_c.html#302">RegisteredMangledName</a>, <a href="variable_c.html#288">ExistingValue</a>, (char *)<a href="variable_c.html#285">Parser</a>-&gtFileName, <a href="variable_c.html#285">Parser</a>-&gtLine, <a href="variable_c.html#285">Parser</a>-&gtCharacterPos);</a>
<a name="328">            *<a href="variable_c.html#285">FirstVisit</a> = TRUE;</a>
<a name="329">        }</a>
<a name="330"></a>
<a name="331">        /* static variable exists in the global scope - now make a mirroring variable in our own scope with the short name */</a>
<a name="332">        <a href="variable_c.html#375">VariableDefinePlatformVar</a>(<a href="variable_c.html#285">Parser</a>-&gtpc, <a href="variable_c.html#285">Parser</a>, <a href="variable_c.html#285">Ident</a>, <a href="variable_c.html#288">ExistingValue</a>-&gtTyp, <a href="variable_c.html#288">ExistingValue</a>-&gtVal, TRUE);</a>
<a name="333">        return <a href="variable_c.html#288">ExistingValue</a>;</a>
<a name="334">    }</a>
<a name="335">    else</a>
<a name="336">    {</a>
<a name="337">        if (<a href="variable_c.html#285">Parser</a>-&gtLine != 0 && <a href="table_c.html#81">TableGet</a>((<a href="variable_c.html#287">pc</a>-&gtTopStackFrame == NULL) ? &<a href="variable_c.html#287">pc</a>-&gtGlobalTable : &<a href="variable_c.html#287">pc</a>-&gtTopStackFrame-&gtLocalTable, <a href="variable_c.html#285">Ident</a>, &<a href="variable_c.html#288">ExistingValue</a>, &<a href="variable_c.html#289">DeclFileName</a>, &<a href="variable_c.html#290">DeclLine</a>, &<a href="variable_c.html#291">DeclColumn</a>)</a>
<a name="338">                && <a href="variable_c.html#289">DeclFileName</a> == <a href="variable_c.html#285">Parser</a>-&gtFileName && <a href="variable_c.html#290">DeclLine</a> == <a href="variable_c.html#285">Parser</a>-&gtLine && <a href="variable_c.html#291">DeclColumn</a> == <a href="variable_c.html#285">Parser</a>-&gtCharacterPos)</a>
<a name="339">            return <a href="variable_c.html#288">ExistingValue</a>;</a>
<a name="340">        else</a>
<a name="341">            return <a href="variable_c.html#259">VariableDefine</a>(<a href="variable_c.html#285">Parser</a>-&gtpc, <a href="variable_c.html#285">Parser</a>, <a href="variable_c.html#285">Ident</a>, NULL, <a href="variable_c.html#285">Typ</a>, TRUE);</a>
<a name="342">    }</a>
<a name="343">}</a>
<a name="344"></a>
<a name="345">/* check if a variable with a given name is defined. Ident must be registered */</a>
<a name="346">int <a name="searched">VariableDefined</a>(Picoc *<a name="searched">pc</a>, const char *<a name="searched">Ident</a>)</a>
<a name="347">{</a>
<a name="348">    struct Value *<a name="searched">FoundValue</a>;</a>
<a name="349">    </a>
<a name="350">    if (<a href="variable_c.html#346">pc</a>-&gtTopStackFrame == NULL || !<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#346">pc</a>-&gtTopStackFrame-&gtLocalTable, <a href="variable_c.html#346">Ident</a>, &<a href="variable_c.html#348">FoundValue</a>, NULL, NULL, NULL))</a>
<a name="351">    {</a>
<a name="352">        if (!<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#346">pc</a>-&gtGlobalTable, <a href="variable_c.html#346">Ident</a>, &<a href="variable_c.html#348">FoundValue</a>, NULL, NULL, NULL))</a>
<a name="353">            return FALSE;</a>
<a name="354">    }</a>
<a name="355"></a>
<a name="356">    return TRUE;</a>
<a name="357">}</a>
<a name="358"></a>
<a name="359">/* get the value of a variable. must be defined. Ident must be registered */</a>
<a name="360">void <a name="searched">VariableGet</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, const char *<a name="searched">Ident</a>, struct Value **<a name="searched">LVal</a>)</a>
<a name="361">{</a>
<a name="362">    if (<a href="variable_c.html#360">pc</a>-&gtTopStackFrame == NULL || !<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#360">pc</a>-&gtTopStackFrame-&gtLocalTable, <a href="variable_c.html#360">Ident</a>, <a href="variable_c.html#360">LVal</a>, NULL, NULL, NULL))</a>
<a name="363">    {</a>
<a name="364">        if (!<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#360">pc</a>-&gtGlobalTable, <a href="variable_c.html#360">Ident</a>, <a href="variable_c.html#360">LVal</a>, NULL, NULL, NULL))</a>
<a name="365">        {</a>
<a name="366">            if (<a href="variable_c.html#241">VariableDefinedAndOutOfScope</a>(<a href="variable_c.html#360">pc</a>, <a href="variable_c.html#360">Ident</a>))</a>
<a name="367">                <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#360">Parser</a>, "'%s' is out of scope", <a href="variable_c.html#360">Ident</a>);</a>
<a name="368">            else</a>
<a name="369">                <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#360">Parser</a>, "'%s' is undefined", <a href="variable_c.html#360">Ident</a>);</a>
<a name="370">        }</a>
<a name="371">    }</a>
<a name="372">}</a>
<a name="373"></a>
<a name="374">/* define a global variable shared with a platform global. Ident will be registered */</a>
<a name="375">void <a name="searched">VariableDefinePlatformVar</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>, char *<a name="searched">Ident</a>, struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, union AnyValue *<a name="searched">FromValue</a>, int <a name="searched">IsWritable</a>)</a>
<a name="376">{</a>
<a name="377">    struct Value *<a name="searched">SomeValue</a> = <a href="variable_c.html#89">VariableAllocValueAndData</a>(<a href="variable_c.html#375">pc</a>, NULL, 0, <a href="variable_c.html#375">IsWritable</a>, NULL, TRUE);</a>
<a name="378">    <a href="variable_c.html#377">SomeValue</a>-&gtTyp = <a href="variable_c.html#375">Typ</a>;</a>
<a name="379">    <a href="variable_c.html#377">SomeValue</a>-&gtVal = <a href="variable_c.html#375">FromValue</a>;</a>
<a name="380">    </a>
<a name="381">    if (!<a href="table_c.html#58">TableSet</a>(<a href="variable_c.html#375">pc</a>, (<a href="variable_c.html#375">pc</a>-&gtTopStackFrame == NULL) ? &<a href="variable_c.html#375">pc</a>-&gtGlobalTable : &<a href="variable_c.html#375">pc</a>-&gtTopStackFrame-&gtLocalTable, <a href="table_c.html#166">TableStrRegister</a>(<a href="variable_c.html#375">pc</a>, <a href="variable_c.html#375">Ident</a>), <a href="variable_c.html#377">SomeValue</a>, <a href="variable_c.html#375">Parser</a> ? <a href="variable_c.html#375">Parser</a>-&gtFileName : NULL, <a href="variable_c.html#375">Parser</a> ? <a href="variable_c.html#375">Parser</a>-&gtLine : 0, <a href="variable_c.html#375">Parser</a> ? <a href="variable_c.html#375">Parser</a>-&gtCharacterPos : 0))</a>
<a name="382">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#375">Parser</a>, "'%s' is already defined", <a href="variable_c.html#375">Ident</a>);</a>
<a name="383">}</a>
<a name="384"></a>
<a name="385">/* free and/or pop the top value off the stack. Var must be the top value on the stack! */</a>
<a name="386">void <a name="searched">Var</a>iableStackPop(struct ParseState *<a name="searched">Parser</a>, struct Value *<a name="searched">Var</a>)</a>
<a name="387">{</a>
<a name="388">    int <a name="searched">Success</a>;</a>
<a name="389">    </a>
<a name="390">#ifdef DEBUG_HEAP</a>
<a name="391">    if (<a href="variable_c.html#386">Var</a>-&gtValOnStack)</a>
<a name="392">        printf("popping %ld at 0x%lx\n", (unsigned long)(sizeof(struct Value) + <a href="type_c.html#69">TypeSizeValue</a>(<a href="variable_c.html#386">Var</a>, FALSE)), (unsigned long)<a href="variable_c.html#386">Var</a>);</a>
<a name="393">#endif</a>
<a name="394">        </a>
<a name="395">    if (<a href="variable_c.html#386">Var</a>-&gtValOnHeap)</a>
<a name="396">    { </a>
<a name="397">        if (<a href="variable_c.html#386">Var</a>-&gtVal != NULL)</a>
<a name="398">            <a href="heap_c.html#226">HeapFreeMem</a>(<a href="variable_c.html#386">Parser</a>-&gtpc, <a href="variable_c.html#386">Var</a>-&gtVal);</a>
<a name="399">            </a>
<a name="400">        <a href="variable_c.html#388">Success</a> = <a href="heap_c.html#92">HeapPopStack</a>(<a href="variable_c.html#386">Parser</a>-&gtpc, <a href="variable_c.html#386">Var</a>, sizeof(struct Value));                       /* free from heap */</a>
<a name="401">    }</a>
<a name="402">    else if (<a href="variable_c.html#386">Var</a>-&gtValOnStack)</a>
<a name="403">        <a href="variable_c.html#388">Success</a> = <a href="heap_c.html#92">HeapPopStack</a>(<a href="variable_c.html#386">Parser</a>-&gtpc, <a href="variable_c.html#386">Var</a>, sizeof(struct Value) + <a href="type_c.html#69">TypeSizeValue</a>(<a href="variable_c.html#386">Var</a>, FALSE));  /* free from stack */</a>
<a name="404">    else</a>
<a name="405">        <a href="variable_c.html#388">Success</a> = <a href="heap_c.html#92">HeapPopStack</a>(<a href="variable_c.html#386">Parser</a>-&gtpc, <a href="variable_c.html#386">Var</a>, sizeof(struct Value));                       /* value isn't our problem */</a>
<a name="406">        </a>
<a name="407">    if (!<a href="variable_c.html#388">Success</a>)</a>
<a name="408">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#386">Parser</a>, "stack underrun");</a>
<a name="409">}</a>
<a name="410"></a>
<a name="411">/* add a stack frame when doing a function call */</a>
<a name="412">void <a name="searched">VariableStackFrameAdd</a>(struct ParseState *<a name="searched">Parser</a>, const char *<a name="searched">FuncName</a>, int <a name="searched">NumParams</a>)</a>
<a name="413">{</a>
<a name="414">    struct StackFrame *<a name="searched">NewFrame</a>;</a>
<a name="415">    </a>
<a name="416">    <a href="heap_c.html#108">HeapPushStackFrame</a>(<a href="variable_c.html#412">Parser</a>-&gtpc);</a>
<a name="417">    <a href="variable_c.html#414">NewFrame</a> = <a href="heap_c.html#67">HeapAllocStack</a>(<a href="variable_c.html#412">Parser</a>-&gtpc, sizeof(struct StackFrame) + sizeof(struct Value *) * <a href="variable_c.html#412">NumParams</a>);</a>
<a name="418">    if (<a href="variable_c.html#414">NewFrame</a> == NULL)</a>
<a name="419">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#412">Parser</a>, "out of memory");</a>
<a name="420">        </a>
<a name="421">    <a href="parse_c.html#429">ParserCopy</a>(&<a href="variable_c.html#414">NewFrame</a>-&gtReturnParser, <a href="variable_c.html#412">Parser</a>);</a>
<a name="422">    <a href="variable_c.html#414">NewFrame</a>-&gtFuncName = <a href="variable_c.html#412">FuncName</a>;</a>
<a name="423">    <a href="variable_c.html#414">NewFrame</a>-&gtParameter = (<a href="variable_c.html#412">NumParams</a> &gt 0) ? ((void *)((char *)<a href="variable_c.html#414">NewFrame</a> + sizeof(struct StackFrame))) : NULL;</a>
<a name="424">    <a href="table_c.html#32">TableInitTable</a>(&<a href="variable_c.html#414">NewFrame</a>-&gtLocalTable, &<a href="variable_c.html#414">NewFrame</a>-&gtLocalHashTable[0], LOCAL_TABLE_SIZE, FALSE);</a>
<a name="425">    <a href="variable_c.html#414">NewFrame</a>-&gtPreviousStackFrame = <a href="variable_c.html#412">Parser</a>-&gtpc-&gtTopStackFrame;</a>
<a name="426">    <a href="variable_c.html#412">Parser</a>-&gtpc-&gtTopStackFrame = <a href="variable_c.html#414">NewFrame</a>;</a>
<a name="427">}</a>
<a name="428"></a>
<a name="429">/* remove a stack frame */</a>
<a name="430">void <a name="searched">VariableStackFramePop</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="431">{</a>
<a name="432">    if (<a href="variable_c.html#430">Parser</a>-&gtpc-&gtTopStackFrame == NULL)</a>
<a name="433">        <a href="platform_c.html#134">ProgramFail</a>(<a href="variable_c.html#430">Parser</a>, "stack is empty - can't go back");</a>
<a name="434">        </a>
<a name="435">    <a href="parse_c.html#429">ParserCopy</a>(<a href="variable_c.html#430">Parser</a>, &<a href="variable_c.html#430">Parser</a>-&gtpc-&gtTopStackFrame-&gtReturnParser);</a>
<a name="436">    <a href="variable_c.html#430">Parser</a>-&gtpc-&gtTopStackFrame = <a href="variable_c.html#430">Parser</a>-&gtpc-&gtTopStackFrame-&gtPreviousStackFrame;</a>
<a name="437">    <a href="heap_c.html#119">HeapPopStackFrame</a>(<a href="variable_c.html#430">Parser</a>-&gtpc);</a>
<a name="438">}</a>
<a name="439"></a>
<a name="440">/* get a string literal. assumes that Ident is already registered. NULL if not found */</a>
<a name="441">struct Value *<a name="searched">VariableStringLiteralGet</a>(Picoc *<a name="searched">pc</a>, char *<a name="searched">Ident</a>)</a>
<a name="442">{</a>
<a name="443">    struct Value *<a name="searched">LVal</a> = NULL;</a>
<a name="444"></a>
<a name="445">    if (<a href="table_c.html#81">TableGet</a>(&<a href="variable_c.html#441">pc</a>-&gtStringLiteralTable, <a href="variable_c.html#441">Ident</a>, &<a href="variable_c.html#443">LVal</a>, NULL, NULL, NULL))</a>
<a name="446">        return <a href="variable_c.html#443">LVal</a>;</a>
<a name="447">    else</a>
<a name="448">        return NULL;</a>
<a name="449">}</a>
<a name="450"></a>
<a name="451">/* define a string literal. assumes that Ident is already registered */</a>
<a name="452">void <a name="searched">VariableStringLiteralDefine</a>(Picoc *<a name="searched">pc</a>, char *<a name="searched">Ident</a>, struct <a name="searched">Val</a>ue *<a name="searched">Val</a>)</a>
<a name="453">{</a>
<a name="454">    <a href="table_c.html#58">TableSet</a>(<a href="variable_c.html#452">pc</a>, &<a href="variable_c.html#452">pc</a>-&gtStringLiteralTable, <a href="variable_c.html#452">Ident</a>, <a href="variable_c.html#452">Val</a>, NULL, 0, 0);</a>
<a name="455">}</a>
<a name="456"></a>
<a name="457">/* check a pointer for validity and dereference it for use */</a>
<a name="458">void *<a name="searched">VariableDereferencePointer</a>(struct ParseState *<a name="searched">Parser</a>, struct Value *<a name="searched">PointerValue</a>, struct Value **<a name="searched">DerefVal</a>, int *<a name="searched">DerefOffset</a>, struct ValueType **<a name="searched">DerefType</a>, int *<a name="searched">DerefIsLValue</a>)</a>
<a name="459">{</a>
<a name="460">    if (<a href="variable_c.html#458">DerefVal</a> != NULL)</a>
<a name="461">        *<a href="variable_c.html#458">DerefVal</a> = NULL;</a>
<a name="462">        </a>
<a name="463">    if (<a href="variable_c.html#458">DerefType</a> != NULL)</a>
<a name="464">        *<a href="variable_c.html#458">DerefType</a> = <a href="variable_c.html#458">PointerValue</a>-&gtTyp-&gtFromType;</a>
<a name="465">        </a>
<a name="466">    if (<a href="variable_c.html#458">DerefOffset</a> != NULL)</a>
<a name="467">        *<a href="variable_c.html#458">DerefOffset</a> = 0;</a>
<a name="468">        </a>
<a name="469">    if (<a href="variable_c.html#458">DerefIsLValue</a> != NULL)</a>
<a name="470">        *<a href="variable_c.html#458">DerefIsLValue</a> = TRUE;</a>
<a name="471"></a>
<a name="472">    return <a href="variable_c.html#458">PointerValue</a>-&gtVal-&gtPointer;</a>
<a name="473">}</a>
</pre></body></html>