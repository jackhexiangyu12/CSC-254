<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head>
<body><pre><a name="1">/* picoc lexer - converts source text into a tokenised form */ </a>
<a name="2"></a>
<a name="3">#include "interpreter.h"</a>
<a name="4"></a>
<a name="5">#ifdef NO_CTYPE</a>
<a name="6">#define isalpha(c) (((c) &gt= 'a' && (c) &lt= 'z') || ((c) &gt= 'A' && (c) &lt= 'Z'))</a>
<a name="7">#define isdigit(c) ((c) &gt= '0' && (c) &lt= '9')</a>
<a name="8">#define isalnum(c) (isalpha(c) || isdigit(c))</a>
<a name="9">#define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\r' || (c) == '\n')</a>
<a name="10">#endif</a>
<a name="11">#define isCidstart(c) (isalpha(c) || (c)=='_' || (c)=='#')</a>
<a name="12">#define isCident(c) (isalnum(c) || (c)=='_')</a>
<a name="13"></a>
<a name="14">#define IS_HEX_ALPHA_DIGIT(c) (((c) &gt= 'a' && (c) &lt= 'f') || ((c) &gt= 'A' && (c) &lt= 'F'))</a>
<a name="15">#define IS_BASE_DIGIT(c,b) (((c) &gt= '0' && (c) &lt '0' + (((b)&lt10)?(b):10)) || (((b) &gt 10) ? IS_HEX_ALPHA_DIGIT(c) : FALSE))</a>
<a name="16">#define GET_BASE_DIGIT(c) (((c) &lt= '9') ? ((c) - '0') : (((c) &lt= 'F') ? ((c) - 'A' + 10) : ((c) - 'a' + 10)))</a>
<a name="17"></a>
<a name="18">#define NEXTIS(c,x,y) { if (NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else GotToken = (y); }</a>
<a name="19">#define NEXTIS3(c,x,d,y,z) { if (NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else NEXTIS(d,y,z) }</a>
<a name="20">#define NEXTIS4(c,x,d,y,e,z,a) { if (NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else NEXTIS3(d,y,e,z,a) }</a>
<a name="21">#define NEXTIS3PLUS(c,x,d,y,e,z,a) { if (NextChar == (c)) { LEXER_INC(Lexer); GotToken = (x); } else if (NextChar == (d)) { if (Lexer-&gtPos[1] == (e)) { LEXER_INCN(Lexer, 2); GotToken = (z); } else { LEXER_INC(Lexer); GotToken = (y); } } else GotToken = (a); }</a>
<a name="22">#define NEXTISEXACTLY3(c,d,y,z) { if (NextChar == (c) && Lexer-&gtPos[1] == (d)) { LEXER_INCN(Lexer, 2); GotToken = (y); } else GotToken = (z); }</a>
<a name="23"></a>
<a name="24">#define LEXER_INC(l) ( (l)-&gtPos++, (l)-&gtCharacterPos++ )</a>
<a name="25">#define LEXER_INCN(l, n) ( (l)-&gtPos+=(n), (l)-&gtCharacterPos+=(n) )</a>
<a name="26">#define TOKEN_DATA_OFFSET 2</a>
<a name="27"></a>
<a name="28">#define MAX_CHAR_VALUE 255      /* maximum value which can be represented by a "char" data type */</a>
<a name="29"></a>
<a name="30"></a>
<a name="31">struct ReservedWord</a>
<a name="32">{</a>
<a name="33">    const char *Word;</a>
<a name="34">    enum LexToken Token;</a>
<a name="35">};</a>
<a name="36"></a>
<a name="37">static struct ReservedWord <a name="searched">ReservedWords</a>[] =</a>
<a name="38">{</a>
<a name="39">    { "#define", TokenHashDefine },</a>
<a name="40">    { "#else", TokenHashElse },</a>
<a name="41">    { "#endif", TokenHashEndif },</a>
<a name="42">    { "#if", TokenHashIf },</a>
<a name="43">    { "#ifdef", TokenHashIfdef },</a>
<a name="44">    { "#ifndef", TokenHashIfndef },</a>
<a name="45">    { "#include", TokenHashInclude },</a>
<a name="46">    { "auto", TokenAutoType },</a>
<a name="47">    { "break", TokenBreak },</a>
<a name="48">    { "case", TokenCase },</a>
<a name="49">    { "char", TokenCharType },</a>
<a name="50">    { "continue", TokenContinue },</a>
<a name="51">    { "default", TokenDefault },</a>
<a name="52">    { "delete", TokenDelete },</a>
<a name="53">    { "do", TokenDo },</a>
<a name="54">#ifndef NO_FP</a>
<a name="55">    { "double", TokenDoubleType },</a>
<a name="56">#endif</a>
<a name="57">    { "else", TokenElse },</a>
<a name="58">    { "enum", TokenEnumType },</a>
<a name="59">    { "extern", TokenExternType },</a>
<a name="60">#ifndef NO_FP</a>
<a name="61">    { "float", TokenFloatType },</a>
<a name="62">#endif</a>
<a name="63">    { "for", TokenFor },</a>
<a name="64">    { "goto", TokenGoto },</a>
<a name="65">    { "if", TokenIf },</a>
<a name="66">    { "int", TokenIntType },</a>
<a name="67">    { "long", TokenLongType },</a>
<a name="68">    { "new", TokenNew },</a>
<a name="69">    { "register", TokenRegisterType },</a>
<a name="70">    { "return", TokenReturn },</a>
<a name="71">    { "short", TokenShortType },</a>
<a name="72">    { "signed", TokenSignedType },</a>
<a name="73">    { "sizeof", TokenSizeof },</a>
<a name="74">    { "static", TokenStaticType },</a>
<a name="75">    { "struct", TokenStructType },</a>
<a name="76">    { "switch", TokenSwitch },</a>
<a name="77">    { "typedef", TokenTypedef },</a>
<a name="78">    { "union", TokenUnionType },</a>
<a name="79">    { "unsigned", TokenUnsignedType },</a>
<a name="80">    { "void", TokenVoidType },</a>
<a name="81">    { "while", TokenWhile }</a>
<a name="82">};</a>
<a name="83"></a>
<a name="84"></a>
<a name="85"></a>
<a name="86">/* initialise the lexer */</a>
<a name="87">void <a name="searched">LexInit</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="88">{</a>
<a name="89">    int <a name="searched">Count</a>;</a>
<a name="90">    </a>
<a name="91">    <a href="table_c.html#32">TableInitTable</a>(&<a href="lex_c.html#87">pc</a>-&gtReservedWordTable, &<a href="lex_c.html#87">pc</a>-&gtReservedWordHashTable[0], sizeof(<a href="lex_c.html#37">ReservedWords</a>) / sizeof(struct ReservedWord) * 2, TRUE);</a>
<a name="92"></a>
<a name="93">    for (<a href="lex_c.html#89">Count</a> = 0; <a href="lex_c.html#89">Count</a> &lt sizeof(<a href="lex_c.html#37">ReservedWords</a>) / sizeof(struct ReservedWord); <a href="lex_c.html#89">Count</a>++)</a>
<a name="94">    {</a>
<a name="95">        <a href="table_c.html#58">TableSet</a>(<a href="lex_c.html#87">pc</a>, &<a href="lex_c.html#87">pc</a>-&gtReservedWordTable, <a href="table_c.html#166">TableStrRegister</a>(<a href="lex_c.html#87">pc</a>, <a href="lex_c.html#37">ReservedWords</a>[<a href="lex_c.html#89">Count</a>].Word), (struct Value *)&<a href="lex_c.html#37">ReservedWords</a>[<a href="lex_c.html#89">Count</a>], NULL, 0, 0);</a>
<a name="96">    }</a>
<a name="97">    </a>
<a name="98">    <a href="lex_c.html#87">pc</a>-&gtLexValue.Typ = NULL;</a>
<a name="99">    <a href="lex_c.html#87">pc</a>-&gtLexValue.Val = &<a href="lex_c.html#87">pc</a>-&gtLexAnyValue;</a>
<a name="100">    <a href="lex_c.html#87">pc</a>-&gtLexValue.LValueFrom = FALSE;</a>
<a name="101">    <a href="lex_c.html#87">pc</a>-&gtLexValue.ValOnHeap = FALSE;</a>
<a name="102">    <a href="lex_c.html#87">pc</a>-&gtLexValue.ValOnStack = FALSE;</a>
<a name="103">    <a href="lex_c.html#87">pc</a>-&gtLexValue.AnyValOnHeap = FALSE;</a>
<a name="104">    <a href="lex_c.html#87">pc</a>-&gtLexValue.IsLValue = FALSE;</a>
<a name="105">}</a>
<a name="106"></a>
<a name="107">/* deallocate */</a>
<a name="108">void <a name="searched">LexCleanup</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="109">{</a>
<a name="110">    int <a name="searched">Count</a>;</a>
<a name="111"></a>
<a name="112">    <a href="lex_c.html#995">LexInteractiveClear</a>(<a href="lex_c.html#108">pc</a>, NULL);</a>
<a name="113"></a>
<a name="114">    for (<a href="lex_c.html#110">Count</a> = 0; <a href="lex_c.html#110">Count</a> &lt sizeof(<a href="lex_c.html#37">ReservedWords</a>) / sizeof(struct ReservedWord); <a href="lex_c.html#110">Count</a>++)</a>
<a name="115">        <a href="table_c.html#101">TableDelete</a>(<a href="lex_c.html#108">pc</a>, &<a href="lex_c.html#108">pc</a>-&gtReservedWordTable, <a href="table_c.html#166">TableStrRegister</a>(<a href="lex_c.html#108">pc</a>, <a href="lex_c.html#37">ReservedWords</a>[<a href="lex_c.html#110">Count</a>].Word));</a>
<a name="116">}</a>
<a name="117"></a>
<a name="118">/* check if a word is a reserved word - used while scanning */</a>
<a name="119">enum LexToken LexCheckReserved<a name="searched">Word</a>(Picoc *<a name="searched">pc</a>, const char *<a name="searched">Word</a>)</a>
<a name="120">{</a>
<a name="121">    struct Value *<a name="searched">val</a>;</a>
<a name="122">    </a>
<a name="123">    if (<a href="table_c.html#81">TableGet</a>(&<a href="lex_c.html#119">pc</a>-&gtReservedWordTable, <a href="lex_c.html#119">Word</a>, &<a href="lex_c.html#121">val</a>, NULL, NULL, NULL))</a>
<a name="124">        return ((struct ReservedWord *)<a href="lex_c.html#121">val</a>)-&gtToken;</a>
<a name="125">    else</a>
<a name="126">        return TokenNone;</a>
<a name="127">}</a>
<a name="128"></a>
<a name="129">/* get a numeric literal - used while scanning */</a>
<a name="130">enum LexToken <a name="searched">LexGetNumber</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, struct <a name="searched">Value</a> *<a name="searched">Value</a>)</a>
<a name="131">{</a>
<a name="132">    long <a name="searched">Result</a> = 0;</a>
<a name="133">    long <a name="searched">Base</a> = 10;</a>
<a name="134">    enum LexToken <a name="searched">ResultToken</a>;</a>
<a name="135">#ifndef NO_FP</a>
<a name="136">    double <a name="searched">FPResult</a>;</a>
<a name="137">    double <a name="searched">FPDiv</a>;</a>
<a name="138">#endif</a>
<a name="139">    /* long/unsigned flags */</a>
<a name="140">#if 0 /* unused for now */</a>
<a name="141">    char IsLong = 0;</a>
<a name="142">    char IsUnsigned = 0;</a>
<a name="143">#endif</a>
<a name="144">    </a>
<a name="145">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == '0')</a>
<a name="146">    { </a>
<a name="147">        /* a binary, octal or hex literal */</a>
<a name="148">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="149">        if (<a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd)</a>
<a name="150">        {</a>
<a name="151">            if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'x' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'X')</a>
<a name="152">                { <a href="lex_c.html#133">Base</a> = 16; LEXER_INC(<a href="lex_c.html#130">Lexer</a>); }</a>
<a name="153">            else if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'b' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'B')</a>
<a name="154">                { <a href="lex_c.html#133">Base</a> = 2; LEXER_INC(<a href="lex_c.html#130">Lexer</a>); }</a>
<a name="155">            else if (*<a href="lex_c.html#130">Lexer</a>-&gtPos != '.')</a>
<a name="156">                <a href="lex_c.html#133">Base</a> = 8;</a>
<a name="157">        }</a>
<a name="158">    }</a>
<a name="159"></a>
<a name="160">    /* get the value */</a>
<a name="161">    for (; <a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd && IS_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos, <a href="lex_c.html#133">Base</a>); LEXER_INC(<a href="lex_c.html#130">Lexer</a>))</a>
<a name="162">        <a href="lex_c.html#132">Result</a> = <a href="lex_c.html#132">Result</a> * <a href="lex_c.html#133">Base</a> + GET_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos);</a>
<a name="163"></a>
<a name="164">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'u' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'U')</a>
<a name="165">    {</a>
<a name="166">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="167">        /* IsUnsigned = 1; */</a>
<a name="168">    }</a>
<a name="169">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'l' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'L')</a>
<a name="170">    {</a>
<a name="171">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="172">        /* IsLong = 1; */</a>
<a name="173">    }</a>
<a name="174">    </a>
<a name="175">    <a href="lex_c.html#130">Value</a>-&gtTyp = &<a href="lex_c.html#130">pc</a>-&gtLongType; /* ignored? */</a>
<a name="176">    <a href="lex_c.html#130">Value</a>-&gtVal-&gtLongInteger = <a href="lex_c.html#132">Result</a>;</a>
<a name="177"></a>
<a name="178">    <a href="lex_c.html#134">ResultToken</a> = TokenIntegerConstant;</a>
<a name="179">    </a>
<a name="180">    if (<a href="lex_c.html#130">Lexer</a>-&gtPos == <a href="lex_c.html#130">Lexer</a>-&gtEnd)</a>
<a name="181">        return <a href="lex_c.html#134">ResultToken</a>;</a>
<a name="182">        </a>
<a name="183">#ifndef NO_FP</a>
<a name="184">    if (<a href="lex_c.html#130">Lexer</a>-&gtPos == <a href="lex_c.html#130">Lexer</a>-&gtEnd)</a>
<a name="185">    {</a>
<a name="186">        return <a href="lex_c.html#134">ResultToken</a>;</a>
<a name="187">    }</a>
<a name="188">    </a>
<a name="189">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos != '.' && *<a href="lex_c.html#130">Lexer</a>-&gtPos != 'e' && *<a href="lex_c.html#130">Lexer</a>-&gtPos != 'E')</a>
<a name="190">    {</a>
<a name="191">        return <a href="lex_c.html#134">ResultToken</a>;</a>
<a name="192">    }</a>
<a name="193">    </a>
<a name="194">    <a href="lex_c.html#130">Value</a>-&gtTyp = &<a href="lex_c.html#130">pc</a>-&gtFPType;</a>
<a name="195">    <a href="lex_c.html#136">FPResult</a> = (double)<a href="lex_c.html#132">Result</a>;</a>
<a name="196">    </a>
<a name="197">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == '.')</a>
<a name="198">    {</a>
<a name="199">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="200">        for (<a href="lex_c.html#137">FPDiv</a> = 1.0/<a href="lex_c.html#133">Base</a>; <a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd && IS_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos, <a href="lex_c.html#133">Base</a>); LEXER_INC(<a href="lex_c.html#130">Lexer</a>), <a href="lex_c.html#137">FPDiv</a> /= (double)<a href="lex_c.html#133">Base</a>)</a>
<a name="201">        {</a>
<a name="202">            <a href="lex_c.html#136">FPResult</a> += GET_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos) * <a href="lex_c.html#137">FPDiv</a>;</a>
<a name="203">        }</a>
<a name="204">    }</a>
<a name="205"></a>
<a name="206">    if (<a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd && (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'e' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'E'))</a>
<a name="207">    {</a>
<a name="208">        int <a name="searched">ExponentSign</a> = 1;</a>
<a name="209">        </a>
<a name="210">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="211">        if (<a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd && *<a href="lex_c.html#130">Lexer</a>-&gtPos == '-')</a>
<a name="212">        {</a>
<a name="213">            <a href="lex_c.html#208">ExponentSign</a> = -1;</a>
<a name="214">            LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="215">        }</a>
<a name="216">        </a>
<a name="217">        <a href="lex_c.html#132">Result</a> = 0;</a>
<a name="218">        while (<a href="lex_c.html#130">Lexer</a>-&gtPos != <a href="lex_c.html#130">Lexer</a>-&gtEnd && IS_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos, <a href="lex_c.html#133">Base</a>))</a>
<a name="219">        {</a>
<a name="220">            <a href="lex_c.html#132">Result</a> = <a href="lex_c.html#132">Result</a> * <a href="lex_c.html#133">Base</a> + GET_BASE_DIGIT(*<a href="lex_c.html#130">Lexer</a>-&gtPos);</a>
<a name="221">            LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="222">        }</a>
<a name="223"></a>
<a name="224">        <a href="lex_c.html#136">FPResult</a> *= pow((double)<a href="lex_c.html#133">Base</a>, (double)<a href="lex_c.html#132">Result</a> * <a href="lex_c.html#208">ExponentSign</a>);</a>
<a name="225">    }</a>
<a name="226">    </a>
<a name="227">    <a href="lex_c.html#130">Value</a>-&gtVal-&gtFP = <a href="lex_c.html#136">FPResult</a>;</a>
<a name="228"></a>
<a name="229">    if (*<a href="lex_c.html#130">Lexer</a>-&gtPos == 'f' || *<a href="lex_c.html#130">Lexer</a>-&gtPos == 'F')</a>
<a name="230">        LEXER_INC(<a href="lex_c.html#130">Lexer</a>);</a>
<a name="231"></a>
<a name="232">    return TokenFPConstant;</a>
<a name="233">#else</a>
<a name="234">    return <a href="lex_c.html#134">ResultToken</a>;</a>
<a name="235">#endif</a>
<a name="236">}</a>
<a name="237"></a>
<a name="238">/* get a reserved word or identifier - used while scanning */</a>
<a name="239">enum LexToken <a name="searched">LexGetWord</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, struct <a name="searched">Value</a> *<a name="searched">Value</a>)</a>
<a name="240">{</a>
<a name="241">    const char *<a name="searched">StartPos</a> = <a href="lex_c.html#239">Lexer</a>-&gtPos;</a>
<a name="242">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a>;</a>
<a name="243">    </a>
<a name="244">    do {</a>
<a name="245">        LEXER_INC(<a href="lex_c.html#239">Lexer</a>);</a>
<a name="246">    } while (<a href="lex_c.html#239">Lexer</a>-&gtPos != <a href="lex_c.html#239">Lexer</a>-&gtEnd && isCident((int)*<a href="lex_c.html#239">Lexer</a>-&gtPos));</a>
<a name="247">    </a>
<a name="248">    <a href="lex_c.html#239">Value</a>-&gtTyp = NULL;</a>
<a name="249">    <a href="lex_c.html#239">Value</a>-&gtVal-&gtIdentifier = <a href="table_c.html#161">TableStrRegister2</a>(<a href="lex_c.html#239">pc</a>, <a href="lex_c.html#241">StartPos</a>, <a href="lex_c.html#239">Lexer</a>-&gtPos - <a href="lex_c.html#241">StartPos</a>);</a>
<a name="250">    </a>
<a name="251">    <a href="lex_c.html#242">Token</a> = <a href="lex_c.html#119">LexCheckReservedWord</a>(<a href="lex_c.html#239">pc</a>, <a href="lex_c.html#239">Value</a>-&gtVal-&gtIdentifier);</a>
<a name="252">    switch (<a href="lex_c.html#242">Token</a>)</a>
<a name="253">    {</a>
<a name="254">        case TokenHashInclude: <a href="lex_c.html#239">Lexer</a>-&gtMode = LexModeHashInclude; break;</a>
<a name="255">        case TokenHashDefine: <a href="lex_c.html#239">Lexer</a>-&gtMode = LexModeHashDefine; break;</a>
<a name="256">        default: break;</a>
<a name="257">    }</a>
<a name="258">        </a>
<a name="259">    if (<a href="lex_c.html#242">Token</a> != TokenNone)</a>
<a name="260">        return <a href="lex_c.html#242">Token</a>;</a>
<a name="261">    </a>
<a name="262">    if (<a href="lex_c.html#239">Lexer</a>-&gtMode == LexModeHashDefineSpace)</a>
<a name="263">        <a href="lex_c.html#239">Lexer</a>-&gtMode = LexModeHashDefineSpaceIdent;</a>
<a name="264">    </a>
<a name="265">    return TokenIdentifier;</a>
<a name="266">}</a>
<a name="267"></a>
<a name="268">/* unescape a character from an octal character constant */</a>
<a name="269">unsigned char <a name="searched">LexUnEscapeCharacterConstant</a>(const char **<a name="searched">From</a>, const char *<a name="searched">End</a>, unsigned char <a name="searched">FirstChar</a>, int <a name="searched">Base</a>)</a>
<a name="270">{</a>
<a name="271">    unsigned char <a name="searched">Total</a> = GET_BASE_DIGIT(<a href="lex_c.html#269">FirstChar</a>);</a>
<a name="272">    int <a name="searched">CCount</a>;</a>
<a name="273">    for (<a href="lex_c.html#272">CCount</a> = 0; IS_BASE_DIGIT(**<a href="lex_c.html#269">From</a>, <a href="lex_c.html#269">Base</a>) && <a href="lex_c.html#272">CCount</a> &lt 2; <a href="lex_c.html#272">CCount</a>++, (*<a href="lex_c.html#269">From</a>)++)</a>
<a name="274">        <a href="lex_c.html#271">Total</a> = <a href="lex_c.html#271">Total</a> * <a href="lex_c.html#269">Base</a> + GET_BASE_DIGIT(**<a href="lex_c.html#269">From</a>);</a>
<a name="275">    </a>
<a name="276">    return <a href="lex_c.html#271">Total</a>;</a>
<a name="277">}</a>
<a name="278"></a>
<a name="279">/* unescape a character from a string or character constant */</a>
<a name="280">unsigned char <a name="searched">LexUnEscapeCharacter</a>(const char **<a name="searched">From</a>, const char *<a name="searched">End</a>)</a>
<a name="281">{</a>
<a name="282">    unsigned char <a name="searched">ThisChar</a>;</a>
<a name="283">    </a>
<a name="284">    while ( *<a href="lex_c.html#280">From</a> != <a href="lex_c.html#280">End</a> && **<a href="lex_c.html#280">From</a> == '\\' && </a>
<a name="285">            &(*<a href="lex_c.html#280">From</a>)[1] != <a href="lex_c.html#280">End</a> && (*<a href="lex_c.html#280">From</a>)[1] == '\n' )</a>
<a name="286">        (*<a href="lex_c.html#280">From</a>) += 2;       /* skip escaped end of lines with LF line termination */</a>
<a name="287">    </a>
<a name="288">    while ( *<a href="lex_c.html#280">From</a> != <a href="lex_c.html#280">End</a> && **<a href="lex_c.html#280">From</a> == '\\' && </a>
<a name="289">            &(*<a href="lex_c.html#280">From</a>)[1] != <a href="lex_c.html#280">End</a> && &(*<a href="lex_c.html#280">From</a>)[2] != <a href="lex_c.html#280">End</a> && (*<a href="lex_c.html#280">From</a>)[1] == '\r' && (*<a href="lex_c.html#280">From</a>)[2] == '\n')</a>
<a name="290">        (*<a href="lex_c.html#280">From</a>) += 3;       /* skip escaped end of lines with CR/LF line termination */</a>
<a name="291">    </a>
<a name="292">    if (*<a href="lex_c.html#280">From</a> == <a href="lex_c.html#280">End</a>)</a>
<a name="293">        return '\\';</a>
<a name="294">    </a>
<a name="295">    if (**<a href="lex_c.html#280">From</a> == '\\')</a>
<a name="296">    { </a>
<a name="297">        /* it's escaped */</a>
<a name="298">        (*<a href="lex_c.html#280">From</a>)++;</a>
<a name="299">        if (*<a href="lex_c.html#280">From</a> == <a href="lex_c.html#280">End</a>)</a>
<a name="300">            return '\\';</a>
<a name="301">        </a>
<a name="302">        <a href="lex_c.html#282">ThisChar</a> = *(*<a href="lex_c.html#280">From</a>)++;</a>
<a name="303">        switch (<a href="lex_c.html#282">ThisChar</a>)</a>
<a name="304">        {</a>
<a name="305">            case '\\': return '\\'; </a>
<a name="306">            case '\'': return '\'';</a>
<a name="307">            case '"':  return '"';</a>
<a name="308">            case 'a':  return '\a';</a>
<a name="309">            case 'b':  return '\b';</a>
<a name="310">            case 'f':  return '\f';</a>
<a name="311">            case 'n':  return '\n';</a>
<a name="312">            case 'r':  return '\r';</a>
<a name="313">            case 't':  return '\t';</a>
<a name="314">            case 'v':  return '\v';</a>
<a name="315">            case '0': case '1': case '2': case '3': return <a href="lex_c.html#269">LexUnEscapeCharacterConstant</a>(<a href="lex_c.html#280">From</a>, <a href="lex_c.html#280">End</a>, <a href="lex_c.html#282">ThisChar</a>, 8);</a>
<a name="316">            case 'x': return <a href="lex_c.html#269">LexUnEscapeCharacterConstant</a>(<a href="lex_c.html#280">From</a>, <a href="lex_c.html#280">End</a>, '0', 16);</a>
<a name="317">            default:   return <a href="lex_c.html#282">ThisChar</a>;</a>
<a name="318">        }</a>
<a name="319">    }</a>
<a name="320">    else</a>
<a name="321">        return *(*<a href="lex_c.html#280">From</a>)++;</a>
<a name="322">}</a>
<a name="323"></a>
<a name="324">/* get a string constant - used while scanning */</a>
<a name="325">enum LexToken <a name="searched">LexGetStringConstant</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, struct <a name="searched">Value</a> *<a name="searched">Value</a>, char <a name="searched">EndChar</a>)</a>
<a name="326">{</a>
<a name="327">    int <a name="searched">Escape</a> = FALSE;</a>
<a name="328">    const char *<a name="searched">StartPos</a> = <a href="lex_c.html#325">Lexer</a>-&gtPos;</a>
<a name="329">    const char *<a name="searched">EndPos</a>;</a>
<a name="330">    char *<a name="searched">EscBuf</a>;</a>
<a name="331">    char *<a name="searched">EscBufPos</a>;</a>
<a name="332">    char *<a name="searched">RegString</a>;</a>
<a name="333">    struct <a href="lex_c.html#325">Value</a> *<a name="searched">ArrayValue</a>;</a>
<a name="334">    </a>
<a name="335">    while (<a href="lex_c.html#325">Lexer</a>-&gtPos != <a href="lex_c.html#325">Lexer</a>-&gtEnd && (*<a href="lex_c.html#325">Lexer</a>-&gtPos != <a href="lex_c.html#325">EndChar</a> || <a href="lex_c.html#327">Escape</a>))</a>
<a name="336">    { </a>
<a name="337">        /* find the end */</a>
<a name="338">        if (<a href="lex_c.html#327">Escape</a>)</a>
<a name="339">        {</a>
<a name="340">            if (*<a href="lex_c.html#325">Lexer</a>-&gtPos == '\r' && <a href="lex_c.html#325">Lexer</a>-&gtPos+1 != <a href="lex_c.html#325">Lexer</a>-&gtEnd)</a>
<a name="341">                <a href="lex_c.html#325">Lexer</a>-&gtPos++;</a>
<a name="342">            </a>
<a name="343">            if (*<a href="lex_c.html#325">Lexer</a>-&gtPos == '\n' && <a href="lex_c.html#325">Lexer</a>-&gtPos+1 != <a href="lex_c.html#325">Lexer</a>-&gtEnd)</a>
<a name="344">            {</a>
<a name="345">                <a href="lex_c.html#325">Lexer</a>-&gtLine++;</a>
<a name="346">                <a href="lex_c.html#325">Lexer</a>-&gtPos++;</a>
<a name="347">                <a href="lex_c.html#325">Lexer</a>-&gtCharacterPos = 0;</a>
<a name="348">                <a href="lex_c.html#325">Lexer</a>-&gtEmitExtraNewlines++;</a>
<a name="349">            }</a>
<a name="350">            </a>
<a name="351">            <a href="lex_c.html#327">Escape</a> = FALSE;</a>
<a name="352">        }</a>
<a name="353">        else if (*<a href="lex_c.html#325">Lexer</a>-&gtPos == '\\')</a>
<a name="354">            <a href="lex_c.html#327">Escape</a> = TRUE;</a>
<a name="355">            </a>
<a name="356">        LEXER_INC(<a href="lex_c.html#325">Lexer</a>);</a>
<a name="357">    }</a>
<a name="358">    <a href="lex_c.html#329">EndPos</a> = <a href="lex_c.html#325">Lexer</a>-&gtPos;</a>
<a name="359">    </a>
<a name="360">    <a href="lex_c.html#330">EscBuf</a> = <a href="heap_c.html#67">HeapAllocStack</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#329">EndPos</a> - <a href="lex_c.html#328">StartPos</a>);</a>
<a name="361">    if (<a href="lex_c.html#330">EscBuf</a> == NULL)</a>
<a name="362">        <a href="platform_c.html#179">LexFail</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#325">Lexer</a>, "out of memory");</a>
<a name="363">    </a>
<a name="364">    for (<a href="lex_c.html#331">EscBufPos</a> = <a href="lex_c.html#330">EscBuf</a>, <a href="lex_c.html#325">Lexer</a>-&gtPos = <a href="lex_c.html#328">StartPos</a>; <a href="lex_c.html#325">Lexer</a>-&gtPos != <a href="lex_c.html#329">EndPos</a>;)</a>
<a name="365">        *<a href="lex_c.html#331">EscBufPos</a>++ = <a href="lex_c.html#280">LexUnEscapeCharacter</a>(&<a href="lex_c.html#325">Lexer</a>-&gtPos, <a href="lex_c.html#329">EndPos</a>);</a>
<a name="366">    </a>
<a name="367">    /* try to find an existing copy of this string literal */</a>
<a name="368">    <a href="lex_c.html#332">RegString</a> = <a href="table_c.html#161">TableStrRegister2</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#330">EscBuf</a>, <a href="lex_c.html#331">EscBufPos</a> - <a href="lex_c.html#330">EscBuf</a>);</a>
<a name="369">    <a href="heap_c.html#92">HeapPopStack</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#330">EscBuf</a>, <a href="lex_c.html#329">EndPos</a> - <a href="lex_c.html#328">StartPos</a>);</a>
<a name="370">    <a href="lex_c.html#333">ArrayValue</a> = <a href="variable_c.html#441">VariableStringLiteralGet</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#332">RegString</a>);</a>
<a name="371">    if (<a href="lex_c.html#333">ArrayValue</a> == NULL)</a>
<a name="372">    {</a>
<a name="373">        /* create and store this string literal */</a>
<a name="374">        <a href="lex_c.html#333">ArrayValue</a> = <a href="variable_c.html#89">VariableAllocValueAndData</a>(<a href="lex_c.html#325">pc</a>, NULL, 0, FALSE, NULL, TRUE);</a>
<a name="375">        <a href="lex_c.html#333">ArrayValue</a>-&gtTyp = <a href="lex_c.html#325">pc</a>-&gtCharArrayType;</a>
<a name="376">        <a href="lex_c.html#333">ArrayValue</a>-&gtVal = (union AnyValue *)<a href="lex_c.html#332">RegString</a>;</a>
<a name="377">        <a href="variable_c.html#452">VariableStringLiteralDefine</a>(<a href="lex_c.html#325">pc</a>, <a href="lex_c.html#332">RegString</a>, <a href="lex_c.html#333">ArrayValue</a>);</a>
<a name="378">    }</a>
<a name="379"></a>
<a name="380">    /* create the the pointer for this char* */</a>
<a name="381">    <a href="lex_c.html#325">Value</a>-&gtTyp = <a href="lex_c.html#325">pc</a>-&gtCharPtrType;</a>
<a name="382">    <a href="lex_c.html#325">Value</a>-&gtVal-&gtPointer = <a href="lex_c.html#332">RegString</a>;</a>
<a name="383">    if (*<a href="lex_c.html#325">Lexer</a>-&gtPos == <a href="lex_c.html#325">EndChar</a>)</a>
<a name="384">        LEXER_INC(<a href="lex_c.html#325">Lexer</a>);</a>
<a name="385">    </a>
<a name="386">    return TokenStringConstant;</a>
<a name="387">}</a>
<a name="388"></a>
<a name="389">/* get a character constant - used while scanning */</a>
<a name="390">enum LexToken <a name="searched">LexGetCharacterConstant</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, struct <a name="searched">Value</a> *<a name="searched">Value</a>)</a>
<a name="391">{</a>
<a name="392">    <a href="lex_c.html#390">Value</a>-&gtTyp = &<a href="lex_c.html#390">pc</a>-&gtCharType;</a>
<a name="393">    <a href="lex_c.html#390">Value</a>-&gtVal-&gtCharacter = <a href="lex_c.html#280">LexUnEscapeCharacter</a>(&<a href="lex_c.html#390">Lexer</a>-&gtPos, <a href="lex_c.html#390">Lexer</a>-&gtEnd);</a>
<a name="394">    if (<a href="lex_c.html#390">Lexer</a>-&gtPos != <a href="lex_c.html#390">Lexer</a>-&gtEnd && *<a href="lex_c.html#390">Lexer</a>-&gtPos != '\'')</a>
<a name="395">        <a href="platform_c.html#179">LexFail</a>(<a href="lex_c.html#390">pc</a>, <a href="lex_c.html#390">Lexer</a>, "expected \"'\"");</a>
<a name="396">        </a>
<a name="397">    LEXER_INC(<a href="lex_c.html#390">Lexer</a>);</a>
<a name="398">    return TokenCharacterConstant;</a>
<a name="399">}</a>
<a name="400"></a>
<a name="401">/* skip a comment - used while scanning */</a>
<a name="402">void <a name="searched">LexSkipComment</a>(struct LexState *<a name="searched">Lexer</a>, char <a name="searched">NextChar</a>, enum LexToken *<a name="searched">ReturnToken</a>)</a>
<a name="403">{</a>
<a name="404">    if (<a href="lex_c.html#402">NextChar</a> == '*')</a>
<a name="405">    {   </a>
<a name="406">        /* conventional C comment */</a>
<a name="407">        while (<a href="lex_c.html#402">Lexer</a>-&gtPos != <a href="lex_c.html#402">Lexer</a>-&gtEnd && (*(<a href="lex_c.html#402">Lexer</a>-&gtPos-1) != '*' || *<a href="lex_c.html#402">Lexer</a>-&gtPos != '/'))</a>
<a name="408">        {</a>
<a name="409">            if (*<a href="lex_c.html#402">Lexer</a>-&gtPos == '\n')</a>
<a name="410">                <a href="lex_c.html#402">Lexer</a>-&gtEmitExtraNewlines++;</a>
<a name="411"></a>
<a name="412">            LEXER_INC(<a href="lex_c.html#402">Lexer</a>);</a>
<a name="413">        }</a>
<a name="414">        </a>
<a name="415">        if (<a href="lex_c.html#402">Lexer</a>-&gtPos != <a href="lex_c.html#402">Lexer</a>-&gtEnd)</a>
<a name="416">            LEXER_INC(<a href="lex_c.html#402">Lexer</a>);</a>
<a name="417">        </a>
<a name="418">        <a href="lex_c.html#402">Lexer</a>-&gtMode = LexModeNormal;</a>
<a name="419">    }</a>
<a name="420">    else</a>
<a name="421">    {   </a>
<a name="422">        /* C++ style comment */</a>
<a name="423">        while (<a href="lex_c.html#402">Lexer</a>-&gtPos != <a href="lex_c.html#402">Lexer</a>-&gtEnd && *<a href="lex_c.html#402">Lexer</a>-&gtPos != '\n')</a>
<a name="424">            LEXER_INC(<a href="lex_c.html#402">Lexer</a>);</a>
<a name="425">    }</a>
<a name="426">}</a>
<a name="427"></a>
<a name="428">/* get a single token from the source - used while scanning */</a>
<a name="429">enum LexToken <a name="searched">LexScanGetToken</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, struct <a name="searched">Value</a> **<a name="searched">Value</a>)</a>
<a name="430">{</a>
<a name="431">    char <a name="searched">ThisChar</a>;</a>
<a name="432">    char <a name="searched">NextChar</a>;</a>
<a name="433">    enum LexToken <a name="searched">GotToken</a> = TokenNone;</a>
<a name="434">    </a>
<a name="435">    /* handle cases line multi-line comments or string constants which mess up the line count */</a>
<a name="436">    if (<a href="lex_c.html#429">Lexer</a>-&gtEmitExtraNewlines &gt 0)</a>
<a name="437">    {</a>
<a name="438">        <a href="lex_c.html#429">Lexer</a>-&gtEmitExtraNewlines--;</a>
<a name="439">        return TokenEndOfLine;</a>
<a name="440">    }</a>
<a name="441">    </a>
<a name="442">    /* scan for a token */</a>
<a name="443">    do</a>
<a name="444">    {</a>
<a name="445">        *<a href="lex_c.html#429">Value</a> = &<a href="lex_c.html#429">pc</a>-&gtLexValue;</a>
<a name="446">        while (<a href="lex_c.html#429">Lexer</a>-&gtPos != <a href="lex_c.html#429">Lexer</a>-&gtEnd && isspace((int)*<a href="lex_c.html#429">Lexer</a>-&gtPos))</a>
<a name="447">        {</a>
<a name="448">            if (*<a href="lex_c.html#429">Lexer</a>-&gtPos == '\n')</a>
<a name="449">            {</a>
<a name="450">                <a href="lex_c.html#429">Lexer</a>-&gtLine++;</a>
<a name="451">                <a href="lex_c.html#429">Lexer</a>-&gtPos++;</a>
<a name="452">                <a href="lex_c.html#429">Lexer</a>-&gtMode = LexModeNormal;</a>
<a name="453">                <a href="lex_c.html#429">Lexer</a>-&gtCharacterPos = 0;</a>
<a name="454">                return TokenEndOfLine;</a>
<a name="455">            }</a>
<a name="456">            else if (<a href="lex_c.html#429">Lexer</a>-&gtMode == LexModeHashDefine || <a href="lex_c.html#429">Lexer</a>-&gtMode == LexModeHashDefineSpace)</a>
<a name="457">                <a href="lex_c.html#429">Lexer</a>-&gtMode = LexModeHashDefineSpace;</a>
<a name="458">            </a>
<a name="459">            else if (<a href="lex_c.html#429">Lexer</a>-&gtMode == LexModeHashDefineSpaceIdent)</a>
<a name="460">                <a href="lex_c.html#429">Lexer</a>-&gtMode = LexModeNormal;</a>
<a name="461">    </a>
<a name="462">            LEXER_INC(<a href="lex_c.html#429">Lexer</a>);</a>
<a name="463">        }</a>
<a name="464">        </a>
<a name="465">        if (<a href="lex_c.html#429">Lexer</a>-&gtPos == <a href="lex_c.html#429">Lexer</a>-&gtEnd || *<a href="lex_c.html#429">Lexer</a>-&gtPos == '\0')</a>
<a name="466">            return TokenEOF;</a>
<a name="467">        </a>
<a name="468">        <a href="lex_c.html#431">ThisChar</a> = *<a href="lex_c.html#429">Lexer</a>-&gtPos;</a>
<a name="469">        if (isCidstart((int)<a href="lex_c.html#431">ThisChar</a>))</a>
<a name="470">            return <a href="lex_c.html#239">LexGetWord</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, *<a href="lex_c.html#429">Value</a>);</a>
<a name="471">        </a>
<a name="472">        if (isdigit((int)<a href="lex_c.html#431">ThisChar</a>))</a>
<a name="473">            return <a href="lex_c.html#130">LexGetNumber</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, *<a href="lex_c.html#429">Value</a>);</a>
<a name="474">        </a>
<a name="475">        <a href="lex_c.html#432">NextChar</a> = (<a href="lex_c.html#429">Lexer</a>-&gtPos+1 != <a href="lex_c.html#429">Lexer</a>-&gtEnd) ? *(<a href="lex_c.html#429">Lexer</a>-&gtPos+1) : 0;</a>
<a name="476">        LEXER_INC(<a href="lex_c.html#429">Lexer</a>);</a>
<a name="477">        switch (<a href="lex_c.html#431">ThisChar</a>)</a>
<a name="478">        {</a>
<a name="479">            case '"': <a href="lex_c.html#433">GotToken</a> = <a href="lex_c.html#325">LexGetStringConstant</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, *<a href="lex_c.html#429">Value</a>, '"'); break;</a>
<a name="480">            case '\'': <a href="lex_c.html#433">GotToken</a> = <a href="lex_c.html#390">LexGetCharacterConstant</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, *<a href="lex_c.html#429">Value</a>); break;</a>
<a name="481">            case '(': if (<a href="lex_c.html#429">Lexer</a>-&gtMode == LexModeHashDefineSpaceIdent) <a href="lex_c.html#433">GotToken</a> = TokenOpenMacroBracket; else <a href="lex_c.html#433">GotToken</a> = TokenOpenBracket; <a href="lex_c.html#429">Lexer</a>-&gtMode = LexModeNormal; break;</a>
<a name="482">            case ')': <a href="lex_c.html#433">GotToken</a> = TokenCloseBracket; break;</a>
<a name="483">            case '=': NEXTIS('=', TokenEqual, TokenAssign); break;</a>
<a name="484">            case '+': NEXTIS3('=', TokenAddAssign, '+', TokenIncrement, TokenPlus); break;</a>
<a name="485">            case '-': NEXTIS4('=', TokenSubtractAssign, '&gt', TokenArrow, '-', TokenDecrement, TokenMinus); break;</a>
<a name="486">            case '*': NEXTIS('=', TokenMultiplyAssign, TokenAsterisk); break;</a>
<a name="487">            case '/': if (<a href="lex_c.html#432">NextChar</a> == '/' || <a href="lex_c.html#432">NextChar</a> == '*') { LEXER_INC(<a href="lex_c.html#429">Lexer</a>); <a href="lex_c.html#402">LexSkipComment</a>(<a href="lex_c.html#429">Lexer</a>, <a href="lex_c.html#432">NextChar</a>, &<a href="lex_c.html#433">GotToken</a>); } else NEXTIS('=', TokenDivideAssign, TokenSlash); break;</a>
<a name="488">            case '%': NEXTIS('=', TokenModulusAssign, TokenModulus); break;</a>
<a name="489">            case '&lt': if (<a href="lex_c.html#429">Lexer</a>-&gtMode == LexModeHashInclude) <a href="lex_c.html#433">GotToken</a> = <a href="lex_c.html#325">LexGetStringConstant</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, *<a href="lex_c.html#429">Value</a>, '&gt'); else { NEXTIS3PLUS('=', TokenLessEqual, '&lt', TokenShiftLeft, '=', TokenShiftLeftAssign, TokenLessThan); } break; </a>
<a name="490">            case '&gt': NEXTIS3PLUS('=', TokenGreaterEqual, '&gt', TokenShiftRight, '=', TokenShiftRightAssign, TokenGreaterThan); break;</a>
<a name="491">            case ';': <a href="lex_c.html#433">GotToken</a> = TokenSemicolon; break;</a>
<a name="492">            case '&': NEXTIS3('=', TokenArithmeticAndAssign, '&', TokenLogicalAnd, TokenAmpersand); break;</a>
<a name="493">            case '|': NEXTIS3('=', TokenArithmeticOrAssign, '|', TokenLogicalOr, TokenArithmeticOr); break;</a>
<a name="494">            case '{': <a href="lex_c.html#433">GotToken</a> = TokenLeftBrace; break;</a>
<a name="495">            case '}': <a href="lex_c.html#433">GotToken</a> = TokenRightBrace; break;</a>
<a name="496">            case '[': <a href="lex_c.html#433">GotToken</a> = TokenLeftSquareBracket; break;</a>
<a name="497">            case ']': <a href="lex_c.html#433">GotToken</a> = TokenRightSquareBracket; break;</a>
<a name="498">            case '!': NEXTIS('=', TokenNotEqual, TokenUnaryNot); break;</a>
<a name="499">            case '^': NEXTIS('=', TokenArithmeticExorAssign, TokenArithmeticExor); break;</a>
<a name="500">            case '~': <a href="lex_c.html#433">GotToken</a> = TokenUnaryExor; break;</a>
<a name="501">            case ',': <a href="lex_c.html#433">GotToken</a> = TokenComma; break;</a>
<a name="502">            case '.': NEXTISEXACTLY3('.', '.', TokenEllipsis, TokenDot); break;</a>
<a name="503">            case '?': <a href="lex_c.html#433">GotToken</a> = TokenQuestionMark; break;</a>
<a name="504">            case ':': <a href="lex_c.html#433">GotToken</a> = TokenColon; break;</a>
<a name="505">            default:  <a href="platform_c.html#179">LexFail</a>(<a href="lex_c.html#429">pc</a>, <a href="lex_c.html#429">Lexer</a>, "illegal character '%c'", <a href="lex_c.html#431">ThisChar</a>); break;</a>
<a name="506">        }</a>
<a name="507">    } while (<a href="lex_c.html#433">GotToken</a> == TokenNone);</a>
<a name="508">    </a>
<a name="509">    return <a href="lex_c.html#433">GotToken</a>;</a>
<a name="510">}</a>
<a name="511"></a>
<a name="512">/* what size value goes with each token */</a>
<a name="513">int Lex<a name="searched">Token</a>Size(enum Lex<a name="searched">Token</a> <a name="searched">Token</a>)</a>
<a name="514">{</a>
<a name="515">    switch (<a href="lex_c.html#513">Token</a>)</a>
<a name="516">    {</a>
<a name="517">        case TokenIdentifier: case TokenStringConstant: return sizeof(char *);</a>
<a name="518">        case TokenIntegerConstant: return sizeof(long);</a>
<a name="519">        case TokenCharacterConstant: return sizeof(unsigned char);</a>
<a name="520">        case TokenFPConstant: return sizeof(double);</a>
<a name="521">        default: return 0;</a>
<a name="522">    }</a>
<a name="523">}</a>
<a name="524"></a>
<a name="525">/* produce tokens from the lexer and return a heap buffer with the result - used for scanning */</a>
<a name="526">void *<a name="searched">LexTokenise</a>(Picoc *<a name="searched">pc</a>, struct LexState *<a name="searched">Lexer</a>, int *<a name="searched">TokenLen</a>)</a>
<a name="527">{</a>
<a name="528">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a>;</a>
<a name="529">    void *<a name="searched">HeapMem</a>;</a>
<a name="530">    struct Value *<a name="searched">GotValue</a>;</a>
<a name="531">    int <a name="searched">MemUsed</a> = 0;</a>
<a name="532">    int <a name="searched">ValueSize</a>;</a>
<a name="533">    int <a name="searched">ReserveSpace</a> = (<a href="lex_c.html#526">Lexer</a>-&gtEnd - <a href="lex_c.html#526">Lexer</a>-&gtPos) * 4 + 16; </a>
<a name="534">    void *<a name="searched">TokenSpace</a> = <a href="heap_c.html#67">HeapAllocStack</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#533">ReserveSpace</a>);</a>
<a name="535">    char *<a name="searched">TokenPos</a> = (char *)<a href="lex_c.html#534">TokenSpace</a>;</a>
<a name="536">    int <a name="searched">LastCharacterPos</a> = 0;</a>
<a name="537"></a>
<a name="538">    if (<a href="lex_c.html#534">TokenSpace</a> == NULL)</a>
<a name="539">        <a href="platform_c.html#179">LexFail</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#526">Lexer</a>, "out of memory");</a>
<a name="540">    </a>
<a name="541">    do</a>
<a name="542">    { </a>
<a name="543">        /* store the token at the end of the stack area */</a>
<a name="544">        <a href="lex_c.html#528">Token</a> = <a href="lex_c.html#429">LexScanGetToken</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#526">Lexer</a>, &<a href="lex_c.html#530">GotValue</a>);</a>
<a name="545"></a>
<a name="546">#ifdef DEBUG_LEXER</a>
<a name="547">        printf("<a href="lex_c.html#528">Token</a>: %02x\n", <a href="lex_c.html#528">Token</a>);</a>
<a name="548">#endif</a>
<a name="549">        *(unsigned char *)<a href="lex_c.html#535">TokenPos</a> = <a href="lex_c.html#528">Token</a>;</a>
<a name="550">        <a href="lex_c.html#535">TokenPos</a>++;</a>
<a name="551">        <a href="lex_c.html#531">MemUsed</a>++;</a>
<a name="552"></a>
<a name="553">        *(unsigned char *)<a href="lex_c.html#535">TokenPos</a> = (unsigned char)<a href="lex_c.html#536">LastCharacterPos</a>;</a>
<a name="554">        <a href="lex_c.html#535">TokenPos</a>++;</a>
<a name="555">        <a href="lex_c.html#531">MemUsed</a>++;</a>
<a name="556"></a>
<a name="557">        <a href="lex_c.html#532">ValueSize</a> = <a href="lex_c.html#513">LexTokenSize</a>(<a href="lex_c.html#528">Token</a>);</a>
<a name="558">        if (<a href="lex_c.html#532">ValueSize</a> &gt 0)</a>
<a name="559">        { </a>
<a name="560">            /* store a value as well */</a>
<a name="561">            memcpy((void *)<a href="lex_c.html#535">TokenPos</a>, (void *)<a href="lex_c.html#530">GotValue</a>-&gtVal, <a href="lex_c.html#532">ValueSize</a>);</a>
<a name="562">            <a href="lex_c.html#535">TokenPos</a> += <a href="lex_c.html#532">ValueSize</a>;</a>
<a name="563">            <a href="lex_c.html#531">MemUsed</a> += <a href="lex_c.html#532">ValueSize</a>;</a>
<a name="564">        }</a>
<a name="565">    </a>
<a name="566">        <a href="lex_c.html#536">LastCharacterPos</a> = <a href="lex_c.html#526">Lexer</a>-&gtCharacterPos;</a>
<a name="567">                    </a>
<a name="568">    } while (<a href="lex_c.html#528">Token</a> != TokenEOF);</a>
<a name="569">    </a>
<a name="570">    <a href="lex_c.html#529">HeapMem</a> = <a href="heap_c.html#135">HeapAllocMem</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#531">MemUsed</a>);</a>
<a name="571">    if (<a href="lex_c.html#529">HeapMem</a> == NULL)</a>
<a name="572">        <a href="platform_c.html#179">LexFail</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#526">Lexer</a>, "out of memory");</a>
<a name="573">        </a>
<a name="574">    assert(<a href="lex_c.html#533">ReserveSpace</a> &gt= <a href="lex_c.html#531">MemUsed</a>);</a>
<a name="575">    memcpy(<a href="lex_c.html#529">HeapMem</a>, <a href="lex_c.html#534">TokenSpace</a>, <a href="lex_c.html#531">MemUsed</a>);</a>
<a name="576">    <a href="heap_c.html#92">HeapPopStack</a>(<a href="lex_c.html#526">pc</a>, <a href="lex_c.html#534">TokenSpace</a>, <a href="lex_c.html#533">ReserveSpace</a>);</a>
<a name="577">#ifdef DEBUG_LEXER</a>
<a name="578">    {</a>
<a name="579">        int Count;</a>
<a name="580">        printf("Tokens: ");</a>
<a name="581">        for (Count = 0; Count &lt <a href="lex_c.html#531">MemUsed</a>; Count++)</a>
<a name="582">            printf("%02x ", *((unsigned char *)<a href="lex_c.html#529">HeapMem</a>+Count));</a>
<a name="583">        printf("\n");</a>
<a name="584">    }</a>
<a name="585">#endif</a>
<a name="586">    if (<a href="lex_c.html#526">TokenLen</a>)</a>
<a name="587">        *<a href="lex_c.html#526">TokenLen</a> = <a href="lex_c.html#531">MemUsed</a>;</a>
<a name="588">    </a>
<a name="589">    return <a href="lex_c.html#529">HeapMem</a>;</a>
<a name="590">}</a>
<a name="591"></a>
<a name="592">/* lexically analyse some source text */</a>
<a name="593">void *<a name="searched">LexAnalyse</a>(Picoc *<a name="searched">pc</a>, const char *<a name="searched">FileName</a>, const char *Source, int <a name="searched">SourceLen</a>, int *<a name="searched">TokenLen</a>)</a>
<a name="594">{</a>
<a name="595">    struct LexState <a name="searched">Lexer</a>;</a>
<a name="596">    </a>
<a name="597">    <a href="lex_c.html#595">Lexer</a>.Pos = <a href="lex_c.html#593">Source</a>;</a>
<a name="598">    <a href="lex_c.html#595">Lexer</a>.End = Source + <a href="lex_c.html#593">SourceLen</a>;</a>
<a name="599">    <a href="lex_c.html#595">Lexer</a>.Line = 1;</a>
<a name="600">    <a href="lex_c.html#595">Lexer</a>.<a href="lex_c.html#593">FileName</a> = <a href="lex_c.html#593">FileName</a>;</a>
<a name="601">    <a href="lex_c.html#595">Lexer</a>.Mode = LexModeNormal;</a>
<a name="602">    <a href="lex_c.html#595">Lexer</a>.EmitExtraNewlines = 0;</a>
<a name="603">    <a href="lex_c.html#595">Lexer</a>.CharacterPos = 1;</a>
<a name="604">    <a href="lex_c.html#595">Lexer</a>.SourceText = <a href="lex_c.html#593">Source</a>;</a>
<a name="605">    </a>
<a name="606">    return <a href="lex_c.html#526">LexTokenise</a>(<a href="lex_c.html#593">pc</a>, &<a href="lex_c.html#595">Lexer</a>, <a href="lex_c.html#593">TokenLen</a>);</a>
<a name="607">}</a>
<a name="608"></a>
<a name="609">/* prepare to parse a pre-tokenised buffer */</a>
<a name="610">void <a href="lex_c.html#87">LexInit</a><a name="searched">Parser</a>(struct ParseState *<a name="searched">Parser</a>, Picoc *<a name="searched">pc</a>, const char *<a name="searched">SourceText</a>, void *<a name="searched">TokenSource</a>, char *<a name="searched">FileName</a>, int <a name="searched">RunIt</a>, int <a name="searched">EnableDebugger</a>)</a>
<a name="611">{</a>
<a name="612">    <a href="lex_c.html#610">Parser</a>-&gtpc = <a href="lex_c.html#610">pc</a>;</a>
<a name="613">    <a href="lex_c.html#610">Parser</a>-&gtPos = <a href="lex_c.html#610">TokenSource</a>;</a>
<a name="614">    <a href="lex_c.html#610">Parser</a>-&gtLine = 1;</a>
<a name="615">    <a href="lex_c.html#610">Parser</a>-&gtFileName = <a href="lex_c.html#610">FileName</a>;</a>
<a name="616">    <a href="lex_c.html#610">Parser</a>-&gtMode = <a href="lex_c.html#610">RunIt</a> ? RunModeRun : RunModeSkip;</a>
<a name="617">    <a href="lex_c.html#610">Parser</a>-&gtSearchLabel = 0;</a>
<a name="618">    <a href="lex_c.html#610">Parser</a>-&gtHashIfLevel = 0;</a>
<a name="619">    <a href="lex_c.html#610">Parser</a>-&gtHashIfEvaluateToLevel = 0;</a>
<a name="620">    <a href="lex_c.html#610">Parser</a>-&gtCharacterPos = 0;</a>
<a name="621">    <a href="lex_c.html#610">Parser</a>-&gtSourceText = <a href="lex_c.html#610">SourceText</a>;</a>
<a name="622">    <a href="lex_c.html#610">Parser</a>-&gtDebugMode = <a href="lex_c.html#610">EnableDebugger</a>;</a>
<a name="623">}</a>
<a name="624"></a>
<a name="625">/* get the next token, without pre-processing */</a>
<a name="626">enum LexToken <a name="searched">LexGetRawToken</a>(struct ParseState *<a name="searched">Parser</a>, struct <a name="searched">Value</a> **<a name="searched">Value</a>, int <a name="searched">IncPos</a>)</a>
<a name="627">{</a>
<a name="628">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a> = <a name="searched">Token</a>None;</a>
<a name="629">    int <a name="searched">ValueSize</a>;</a>
<a name="630">    char *<a name="searched">Prompt</a> = NULL;</a>
<a name="631">    Picoc *<a name="searched">pc</a> = <a href="lex_c.html#626">Parser</a>-&gt<a name="searched">pc</a>;</a>
<a name="632">    </a>
<a name="633">    do</a>
<a name="634">    { </a>
<a name="635">        /* get the next token */</a>
<a name="636">        if (<a href="lex_c.html#626">Parser</a>-&gtPos == NULL && <a href="lex_c.html#631">pc</a>-&gtInteractiveHead != NULL)</a>
<a name="637">            <a href="lex_c.html#626">Parser</a>-&gtPos = <a href="lex_c.html#631">pc</a>-&gtInteractiveHead-&gtTokens;</a>
<a name="638">        </a>
<a name="639">        if (<a href="lex_c.html#626">Parser</a>-&gtFileName != <a href="lex_c.html#631">pc</a>-&gtStrEmpty || <a href="lex_c.html#631">pc</a>-&gtInteractiveHead != NULL)</a>
<a name="640">        { </a>
<a name="641">            /* skip leading newlines */</a>
<a name="642">            while ((<a href="lex_c.html#628">Token</a> = (enum LexToken)*(unsigned char *)<a href="lex_c.html#626">Parser</a>-&gtPos) == TokenEndOfLine)</a>
<a name="643">            {</a>
<a name="644">                <a href="lex_c.html#626">Parser</a>-&gtLine++;</a>
<a name="645">                <a href="lex_c.html#626">Parser</a>-&gtPos += TOKEN_DATA_OFFSET;</a>
<a name="646">            }</a>
<a name="647">        }</a>
<a name="648">    </a>
<a name="649">        if (<a href="lex_c.html#626">Parser</a>-&gtFileName == <a href="lex_c.html#631">pc</a>-&gtStrEmpty && (<a href="lex_c.html#631">pc</a>-&gtInteractiveHead == NULL || <a href="lex_c.html#628">Token</a> == TokenEOF))</a>
<a name="650">        { </a>
<a name="651">            /* we're at the end of an interactive input token list */</a>
<a name="652">            char <a name="searched">LineBuffer</a>[LINEBUFFER_MAX];</a>
<a name="653">            void *<a name="searched">LineTokens</a>;</a>
<a name="654">            int <a name="searched">LineBytes</a>;</a>
<a name="655">            struct TokenLine *<a name="searched">LineNode</a>;</a>
<a name="656">            </a>
<a name="657">            if (<a href="lex_c.html#631">pc</a>-&gtInteractiveHead == NULL || (unsigned char *)<a href="lex_c.html#626">Parser</a>-&gtPos == &<a href="lex_c.html#631">pc</a>-&gtInteractiveTail-&gtTokens[<a href="lex_c.html#631">pc</a>-&gtInteractiveTail-&gtNumBytes-TOKEN_DATA_OFFSET])</a>
<a name="658">            { </a>
<a name="659">                /* get interactive input */</a>
<a name="660">                if (<a href="lex_c.html#631">pc</a>-&gtLexUseStatementPrompt)</a>
<a name="661">                {</a>
<a name="662">                    <a href="lex_c.html#630">Prompt</a> = INTERACTIVE_PROMPT_STATEMENT;</a>
<a name="663">                    <a href="lex_c.html#631">pc</a>-&gtLexUseStatementPrompt = FALSE;</a>
<a name="664">                }</a>
<a name="665">                else</a>
<a name="666">                    <a href="lex_c.html#630">Prompt</a> = INTERACTIVE_PROMPT_LINE;</a>
<a name="667">                    </a>
<a name="668">                if (<a href="platform_unix_c.html#39">PlatformGetLine</a>(&<a href="lex_c.html#652">LineBuffer</a>[0], LINEBUFFER_MAX, <a href="lex_c.html#630">Prompt</a>) == NULL)</a>
<a name="669">                    return TokenEOF;</a>
<a name="670"></a>
<a name="671">                /* put the new line at the end of the linked list of interactive lines */        </a>
<a name="672">                <a href="lex_c.html#653">LineTokens</a> = <a href="lex_c.html#593">LexAnalyse</a>(<a href="lex_c.html#631">pc</a>, <a href="lex_c.html#631">pc</a>-&gtStrEmpty, &<a href="lex_c.html#652">LineBuffer</a>[0], strlen(<a href="lex_c.html#652">LineBuffer</a>), &<a href="lex_c.html#654">LineBytes</a>);</a>
<a name="673">                <a href="lex_c.html#655">LineNode</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="lex_c.html#631">pc</a>, <a href="lex_c.html#626">Parser</a>, sizeof(struct TokenLine), TRUE);</a>
<a name="674">                <a href="lex_c.html#655">LineNode</a>-&gtTokens = <a href="lex_c.html#653">LineTokens</a>;</a>
<a name="675">                <a href="lex_c.html#655">LineNode</a>-&gtNumBytes = <a href="lex_c.html#654">LineBytes</a>;</a>
<a name="676">                if (<a href="lex_c.html#631">pc</a>-&gtInteractiveHead == NULL)</a>
<a name="677">                { </a>
<a name="678">                    /* start a new list */</a>
<a name="679">                    <a href="lex_c.html#631">pc</a>-&gtInteractiveHead = <a href="lex_c.html#655">LineNode</a>;</a>
<a name="680">                    <a href="lex_c.html#626">Parser</a>-&gtLine = 1;</a>
<a name="681">                    <a href="lex_c.html#626">Parser</a>-&gtCharacterPos = 0;</a>
<a name="682">                }</a>
<a name="683">                else</a>
<a name="684">                    <a href="lex_c.html#631">pc</a>-&gtInteractiveTail-&gtNext = <a href="lex_c.html#655">LineNode</a>;</a>
<a name="685"></a>
<a name="686">                <a href="lex_c.html#631">pc</a>-&gtInteractiveTail = <a href="lex_c.html#655">LineNode</a>;</a>
<a name="687">                <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#655">LineNode</a>;</a>
<a name="688">                <a href="lex_c.html#626">Parser</a>-&gtPos = <a href="lex_c.html#653">LineTokens</a>;</a>
<a name="689">            }</a>
<a name="690">            else</a>
<a name="691">            { </a>
<a name="692">                /* go to the next token line */</a>
<a name="693">                if (<a href="lex_c.html#626">Parser</a>-&gtPos != &<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes-TOKEN_DATA_OFFSET])</a>
<a name="694">                { </a>
<a name="695">                    /* scan for the line */</a>
<a name="696">                    for (<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#631">pc</a>-&gtInteractiveHead; <a href="lex_c.html#626">Parser</a>-&gtPos != &<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes-TOKEN_DATA_OFFSET]; <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtNext)</a>
<a name="697">                    { assert(<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtNext != NULL); }</a>
<a name="698">                }</a>
<a name="699"></a>
<a name="700">                assert(<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine != NULL);</a>
<a name="701">                <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtNext;</a>
<a name="702">                assert(<a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine != NULL);</a>
<a name="703">                <a href="lex_c.html#626">Parser</a>-&gtPos = <a href="lex_c.html#631">pc</a>-&gtInteractiveCurrentLine-&gtTokens;</a>
<a name="704">            }</a>
<a name="705"></a>
<a name="706">            <a href="lex_c.html#628">Token</a> = (enum LexToken)*(unsigned char *)<a href="lex_c.html#626">Parser</a>-&gtPos;</a>
<a name="707">        }</a>
<a name="708">    } while ((<a href="lex_c.html#626">Parser</a>-&gtFileName == <a href="lex_c.html#631">pc</a>-&gtStrEmpty && <a href="lex_c.html#628">Token</a> == TokenEOF) || <a href="lex_c.html#628">Token</a> == TokenEndOfLine);</a>
<a name="709"></a>
<a name="710">    <a href="lex_c.html#626">Parser</a>-&gtCharacterPos = *((unsigned char *)<a href="lex_c.html#626">Parser</a>-&gtPos + 1);</a>
<a name="711">    <a href="lex_c.html#629">ValueSize</a> = <a href="lex_c.html#513">LexTokenSize</a>(<a href="lex_c.html#628">Token</a>);</a>
<a name="712">    if (<a href="lex_c.html#629">ValueSize</a> &gt 0)</a>
<a name="713">    { </a>
<a name="714">        /* this token requires a value - unpack it */</a>
<a name="715">        if (<a href="lex_c.html#626">Value</a> != NULL)</a>
<a name="716">        { </a>
<a name="717">            switch (<a href="lex_c.html#628">Token</a>)</a>
<a name="718">            {</a>
<a name="719">                case TokenStringConstant:       <a href="lex_c.html#631">pc</a>-&gtLexValue.Typ = <a href="lex_c.html#631">pc</a>-&gtCharPtrType; break;</a>
<a name="720">                case TokenIdentifier:           <a href="lex_c.html#631">pc</a>-&gtLexValue.Typ = NULL; break;</a>
<a name="721">                case TokenIntegerConstant:      <a href="lex_c.html#631">pc</a>-&gtLexValue.Typ = &<a href="lex_c.html#631">pc</a>-&gtLongType; break;</a>
<a name="722">                case TokenCharacterConstant:    <a href="lex_c.html#631">pc</a>-&gtLexValue.Typ = &<a href="lex_c.html#631">pc</a>-&gtCharType; break;</a>
<a name="723">#ifndef NO_FP</a>
<a name="724">                case TokenFPConstant:           <a href="lex_c.html#631">pc</a>-&gtLexValue.Typ = &<a href="lex_c.html#631">pc</a>-&gtFPType; break;</a>
<a name="725">#endif</a>
<a name="726">                default: break;</a>
<a name="727">            }</a>
<a name="728">            </a>
<a name="729">            memcpy((void *)<a href="lex_c.html#631">pc</a>-&gtLexValue.Val, (void *)((char *)<a href="lex_c.html#626">Parser</a>-&gtPos + TOKEN_DATA_OFFSET), <a href="lex_c.html#629">ValueSize</a>);</a>
<a name="730">            <a href="lex_c.html#631">pc</a>-&gtLexValue.ValOnHeap = FALSE;</a>
<a name="731">            <a href="lex_c.html#631">pc</a>-&gtLexValue.ValOnStack = FALSE;</a>
<a name="732">            <a href="lex_c.html#631">pc</a>-&gtLexValue.IsLValue = FALSE;</a>
<a name="733">            <a href="lex_c.html#631">pc</a>-&gtLexValue.LValueFrom = NULL;</a>
<a name="734">            *<a href="lex_c.html#626">Value</a> = &<a href="lex_c.html#631">pc</a>-&gtLexValue;</a>
<a name="735">        }</a>
<a name="736">        </a>
<a name="737">        if (<a href="lex_c.html#626">IncPos</a>)</a>
<a name="738">            <a href="lex_c.html#626">Parser</a>-&gtPos += <a href="lex_c.html#629">ValueSize</a> + TOKEN_DATA_OFFSET;</a>
<a name="739">    }</a>
<a name="740">    else</a>
<a name="741">    {</a>
<a name="742">        if (<a href="lex_c.html#626">IncPos</a> && <a href="lex_c.html#628">Token</a> != TokenEOF)</a>
<a name="743">            <a href="lex_c.html#626">Parser</a>-&gtPos += TOKEN_DATA_OFFSET;</a>
<a name="744">    }</a>
<a name="745">    </a>
<a name="746">#ifdef DEBUG_LEXER</a>
<a name="747">    printf("Got token=%02x inc=%d pos=%d\n", <a href="lex_c.html#628">Token</a>, <a href="lex_c.html#626">IncPos</a>, <a href="lex_c.html#626">Parser</a>-&gtCharacterPos);</a>
<a name="748">#endif</a>
<a name="749">    assert(<a href="lex_c.html#628">Token</a> &gt= TokenNone && <a href="lex_c.html#628">Token</a> &lt= TokenEndOfFunction);</a>
<a name="750">    return <a href="lex_c.html#628">Token</a>;</a>
<a name="751">}</a>
<a name="752"></a>
<a name="753">/* correct the token position depending if we already incremented the position */</a>
<a name="754">void LexHash<a name="searched">IncPos</a>(struct ParseState *<a name="searched">Parser</a>, int <a name="searched">IncPos</a>)</a>
<a name="755">{</a>
<a name="756">    if (!<a href="lex_c.html#754">IncPos</a>)</a>
<a name="757">        <a href="lex_c.html#626">LexGetRawToken</a>(<a href="lex_c.html#754">Parser</a>, NULL, TRUE);</a>
<a name="758">}</a>
<a name="759"></a>
<a name="760">/* handle a #ifdef directive */</a>
<a name="761">void <a name="searched">LexHashIfdef</a>(struct ParseState *<a name="searched">Parser</a>, int <a name="searched">IfNot</a>)</a>
<a name="762">{</a>
<a name="763">    /* get symbol to check */</a>
<a name="764">    struct Value *<a name="searched">IdentValue</a>;</a>
<a name="765">    struct Value *<a name="searched">SavedValue</a>;</a>
<a name="766">    int <a name="searched">IsDefined</a>;</a>
<a name="767">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a> = LexGetRaw<a name="searched">Token</a>(<a href="lex_c.html#761">Parser</a>, &<a href="lex_c.html#764">IdentValue</a>, TRUE);</a>
<a name="768">    </a>
<a name="769">    if (<a href="lex_c.html#767">Token</a> != TokenIdentifier)</a>
<a name="770">        <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#761">Parser</a>, "identifier expected");</a>
<a name="771">    </a>
<a name="772">    /* is the identifier defined? */</a>
<a name="773">    <a href="lex_c.html#766">IsDefined</a> = <a href="table_c.html#81">TableGet</a>(&<a href="lex_c.html#761">Parser</a>-&gtpc-&gtGlobalTable, <a href="lex_c.html#764">IdentValue</a>-&gtVal-&gtIdentifier, &<a href="lex_c.html#765">SavedValue</a>, NULL, NULL, NULL);</a>
<a name="774">    if (<a href="lex_c.html#761">Parser</a>-&gtHashIfEvaluateToLevel == <a href="lex_c.html#761">Parser</a>-&gtHashIfLevel && ( (<a href="lex_c.html#766">IsDefined</a> && !<a href="lex_c.html#761">IfNot</a>) || (!<a href="lex_c.html#766">IsDefined</a> && <a href="lex_c.html#761">IfNot</a>)) )</a>
<a name="775">    {</a>
<a name="776">        /* #if is active, evaluate to this new level */</a>
<a name="777">        <a href="lex_c.html#761">Parser</a>-&gtHashIfEvaluateToLevel++;</a>
<a name="778">    }</a>
<a name="779">    </a>
<a name="780">    <a href="lex_c.html#761">Parser</a>-&gtHashIfLevel++;</a>
<a name="781">}</a>
<a name="782"></a>
<a name="783">/* handle a #if directive */</a>
<a name="784">void <a name="searched">LexHashIf</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="785">{</a>
<a name="786">    /* get symbol to check */</a>
<a name="787">    struct Value *<a name="searched">IdentValue</a>;</a>
<a name="788">    struct Value *<a name="searched">SavedValue</a> = NULL;</a>
<a name="789">    struct ParseState <a name="searched">MacroParser</a>;</a>
<a name="790">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a> = LexGetRaw<a name="searched">Token</a>(<a href="lex_c.html#784">Parser</a>, &<a href="lex_c.html#787">IdentValue</a>, TRUE);</a>
<a name="791"></a>
<a name="792">    if (<a href="lex_c.html#790">Token</a> == TokenIdentifier)</a>
<a name="793">    {</a>
<a name="794">        /* look up a value from a macro definition */</a>
<a name="795">        if (!<a href="table_c.html#81">TableGet</a>(&<a href="lex_c.html#784">Parser</a>-&gtpc-&gtGlobalTable, <a href="lex_c.html#787">IdentValue</a>-&gtVal-&gtIdentifier, &<a href="lex_c.html#788">SavedValue</a>, NULL, NULL, NULL))</a>
<a name="796">            <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#784">Parser</a>, "'%s' is undefined", <a href="lex_c.html#787">IdentValue</a>-&gtVal-&gtIdentifier);</a>
<a name="797">        </a>
<a name="798">        if (<a href="lex_c.html#788">SavedValue</a>-&gtTyp-&gtBase != TypeMacro)</a>
<a name="799">            <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#784">Parser</a>, "value expected");</a>
<a name="800">        </a>
<a name="801">        <a href="parse_c.html#429">ParserCopy</a>(&<a href="lex_c.html#789">MacroParser</a>, &<a href="lex_c.html#788">SavedValue</a>-&gtVal-&gtMacroDef.Body);</a>
<a name="802">        <a href="lex_c.html#790">Token</a> = <a href="lex_c.html#626">LexGetRawToken</a>(&<a href="lex_c.html#789">MacroParser</a>, &<a href="lex_c.html#787">IdentValue</a>, TRUE);</a>
<a name="803">    }</a>
<a name="804">    </a>
<a name="805">    if (<a href="lex_c.html#790">Token</a> != TokenCharacterConstant && <a href="lex_c.html#790">Token</a> != TokenIntegerConstant)</a>
<a name="806">        <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#784">Parser</a>, "value expected");</a>
<a name="807">    </a>
<a name="808">    /* is the identifier defined? */</a>
<a name="809">    if (<a href="lex_c.html#784">Parser</a>-&gtHashIfEvaluateToLevel == <a href="lex_c.html#784">Parser</a>-&gtHashIfLevel && <a href="lex_c.html#787">IdentValue</a>-&gtVal-&gtCharacter)</a>
<a name="810">    {</a>
<a name="811">        /* #if is active, evaluate to this new level */</a>
<a name="812">        <a href="lex_c.html#784">Parser</a>-&gtHashIfEvaluateToLevel++;</a>
<a name="813">    }</a>
<a name="814">    </a>
<a name="815">    <a href="lex_c.html#784">Parser</a>-&gtHashIfLevel++;</a>
<a name="816">}</a>
<a name="817"></a>
<a name="818">/* handle a #else directive */</a>
<a name="819">void <a name="searched">LexHashElse</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="820">{</a>
<a name="821">    if (<a href="lex_c.html#819">Parser</a>-&gtHashIfEvaluateToLevel == <a href="lex_c.html#819">Parser</a>-&gtHashIfLevel - 1)</a>
<a name="822">        <a href="lex_c.html#819">Parser</a>-&gtHashIfEvaluateToLevel++;     /* #if was not active, make this next section active */</a>
<a name="823">        </a>
<a name="824">    else if (<a href="lex_c.html#819">Parser</a>-&gtHashIfEvaluateToLevel == <a href="lex_c.html#819">Parser</a>-&gtHashIfLevel)</a>
<a name="825">    {</a>
<a name="826">        /* #if was active, now go inactive */</a>
<a name="827">        if (<a href="lex_c.html#819">Parser</a>-&gtHashIfLevel == 0)</a>
<a name="828">            <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#819">Parser</a>, "#else without #if");</a>
<a name="829">            </a>
<a name="830">        <a href="lex_c.html#819">Parser</a>-&gtHashIfEvaluateToLevel--;</a>
<a name="831">    }</a>
<a name="832">}</a>
<a name="833"></a>
<a name="834">/* handle a #endif directive */</a>
<a name="835">void <a name="searched">LexHashEndif</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="836">{</a>
<a name="837">    if (<a href="lex_c.html#835">Parser</a>-&gtHashIfLevel == 0)</a>
<a name="838">        <a href="platform_c.html#134">ProgramFail</a>(<a href="lex_c.html#835">Parser</a>, "#endif without #if");</a>
<a name="839"></a>
<a name="840">    <a href="lex_c.html#835">Parser</a>-&gtHashIfLevel--;</a>
<a name="841">    if (<a href="lex_c.html#835">Parser</a>-&gtHashIfEvaluateToLevel &gt <a href="lex_c.html#835">Parser</a>-&gtHashIfLevel)</a>
<a name="842">        <a href="lex_c.html#835">Parser</a>-&gtHashIfEvaluateToLevel = <a href="lex_c.html#835">Parser</a>-&gtHashIfLevel;</a>
<a name="843">}</a>
<a name="844"></a>
<a name="845">#if 0 /* useful for debug */</a>
<a name="846">void LexPrintToken(enum LexToken Token)</a>
<a name="847">{</a>
<a name="848">    char* TokenNames[] = {</a>
<a name="849">        /* 0x00 */ "None", </a>
<a name="850">        /* 0x01 */ "Comma",</a>
<a name="851">        /* 0x02 */ "Assign", "AddAssign", "SubtractAssign", "MultiplyAssign", "DivideAssign", "ModulusAssign",</a>
<a name="852">        /* 0x08 */ "ShiftLeftAssign", "ShiftRightAssign", "ArithmeticAndAssign", "ArithmeticOrAssign", "ArithmeticExorAssign",</a>
<a name="853">        /* 0x0d */ "QuestionMark", "Colon", </a>
<a name="854">        /* 0x0f */ "LogicalOr", </a>
<a name="855">        /* 0x10 */ "LogicalAnd", </a>
<a name="856">        /* 0x11 */ "ArithmeticOr", </a>
<a name="857">        /* 0x12 */ "ArithmeticExor", </a>
<a name="858">        /* 0x13 */ "Ampersand", </a>
<a name="859">        /* 0x14 */ "Equal", "NotEqual", </a>
<a name="860">        /* 0x16 */ "LessThan", "GreaterThan", "LessEqual", "GreaterEqual",</a>
<a name="861">        /* 0x1a */ "ShiftLeft", "ShiftRight", </a>
<a name="862">        /* 0x1c */ "Plus", "Minus", </a>
<a name="863">        /* 0x1e */ "Asterisk", "Slash", "Modulus",</a>
<a name="864">        /* 0x21 */ "Increment", "Decrement", "UnaryNot", "UnaryExor", "Sizeof", "Cast",</a>
<a name="865">        /* 0x27 */ "LeftSquareBracket", "RightSquareBracket", "Dot", "Arrow", </a>
<a name="866">        /* 0x2b */ "OpenBracket", "CloseBracket",</a>
<a name="867">        /* 0x2d */ "Identifier", "IntegerConstant", "FPConstant", "StringConstant", "CharacterConstant",</a>
<a name="868">        /* 0x32 */ "Semicolon", "Ellipsis",</a>
<a name="869">        /* 0x34 */ "LeftBrace", "RightBrace",</a>
<a name="870">        /* 0x36 */ "IntType", "CharType", "FloatType", "DoubleType", "VoidType", "EnumType",</a>
<a name="871">        /* 0x3c */ "LongType", "SignedType", "ShortType", "StaticType", "AutoType", "RegisterType", "ExternType", "StructType", "UnionType", "UnsignedType", "Typedef",</a>
<a name="872">        /* 0x46 */ "Continue", "Do", "Else", "For", "Goto", "If", "While", "Break", "Switch", "Case", "Default", "Return",</a>
<a name="873">        /* 0x52 */ "HashDefine", "HashInclude", "HashIf", "HashIfdef", "HashIfndef", "HashElse", "HashEndif",</a>
<a name="874">        /* 0x59 */ "New", "Delete",</a>
<a name="875">        /* 0x5b */ "OpenMacroBracket",</a>
<a name="876">        /* 0x5c */ "EOF", "EndOfLine", "EndOfFunction"</a>
<a name="877">    };</a>
<a name="878">    printf("{%s}", TokenNames[Token]);</a>
<a name="879">}</a>
<a name="880">#endif</a>
<a name="881"></a>
<a name="882">/* get the next token given a parser state, pre-processing as we go */</a>
<a name="883">enum LexToken <a name="searched">LexGetToken</a>(struct ParseState *<a name="searched">Parser</a>, struct <a name="searched">Value</a> **<a name="searched">Value</a>, int <a name="searched">IncPos</a>)</a>
<a name="884">{</a>
<a name="885">    enum Lex<a name="searched">Token</a> <a name="searched">Token</a>;</a>
<a name="886">    int <a name="searched">TryNextToken</a>;</a>
<a name="887">    </a>
<a name="888">    /* implements the pre-processor #if commands */</a>
<a name="889">    do</a>
<a name="890">    {</a>
<a name="891">        int <a name="searched">WasPreProcToken</a> = TRUE;</a>
<a name="892"></a>
<a name="893">        <a href="lex_c.html#885">Token</a> = <a href="lex_c.html#626">LexGetRawToken</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">Value</a>, <a href="lex_c.html#883">IncPos</a>);</a>
<a name="894">        switch (<a href="lex_c.html#885">Token</a>)</a>
<a name="895">        {</a>
<a name="896">            case TokenHashIfdef:    <a href="lex_c.html#754">LexHashIncPos</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">IncPos</a>); <a href="lex_c.html#761">LexHashIfdef</a>(<a href="lex_c.html#883">Parser</a>, FALSE); break;</a>
<a name="897">            case TokenHashIfndef:   <a href="lex_c.html#754">LexHashIncPos</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">IncPos</a>); <a href="lex_c.html#761">LexHashIfdef</a>(<a href="lex_c.html#883">Parser</a>, TRUE); break;</a>
<a name="898">            case TokenHashIf:       <a href="lex_c.html#754">LexHashIncPos</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">IncPos</a>); <a href="lex_c.html#784">LexHashIf</a>(<a href="lex_c.html#883">Parser</a>); break;</a>
<a name="899">            case TokenHashElse:     <a href="lex_c.html#754">LexHashIncPos</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">IncPos</a>); <a href="lex_c.html#819">LexHashElse</a>(<a href="lex_c.html#883">Parser</a>); break;</a>
<a name="900">            case TokenHashEndif:    <a href="lex_c.html#754">LexHashIncPos</a>(<a href="lex_c.html#883">Parser</a>, <a href="lex_c.html#883">IncPos</a>); <a href="lex_c.html#835">LexHashEndif</a>(<a href="lex_c.html#883">Parser</a>); break;</a>
<a name="901">            default:                <a href="lex_c.html#891">WasPreProcToken</a> = FALSE; break;</a>
<a name="902">        }</a>
<a name="903"></a>
<a name="904">        /* if we're going to reject this token, increment the token pointer to the next one */</a>
<a name="905">        <a href="lex_c.html#886">TryNextToken</a> = (<a href="lex_c.html#883">Parser</a>-&gtHashIfEvaluateToLevel &lt <a href="lex_c.html#883">Parser</a>-&gtHashIfLevel && <a href="lex_c.html#885">Token</a> != TokenEOF) || <a href="lex_c.html#891">WasPreProcToken</a>;</a>
<a name="906">        if (!<a href="lex_c.html#883">IncPos</a> && <a href="lex_c.html#886">TryNextToken</a>)</a>
<a name="907">            <a href="lex_c.html#626">LexGetRawToken</a>(<a href="lex_c.html#883">Parser</a>, NULL, TRUE);</a>
<a name="908">            </a>
<a name="909">    } while (<a href="lex_c.html#886">TryNextToken</a>);</a>
<a name="910">    </a>
<a name="911">    return <a href="lex_c.html#885">Token</a>;</a>
<a name="912">}</a>
<a name="913"></a>
<a name="914">/* take a quick peek at the next token, skipping any pre-processing */</a>
<a name="915">enum LexToken <a name="searched">LexRawPeekToken</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="916">{</a>
<a name="917">    return (enum LexToken)*(unsigned char *)<a href="lex_c.html#915">Parser</a>-&gtPos;</a>
<a name="918">}</a>
<a name="919"></a>
<a name="920">/* find the end of the line */</a>
<a name="921">void <a name="searched">LexToEndOfLine</a>(struct ParseState *<a name="searched">Parser</a>)</a>
<a name="922">{</a>
<a name="923">    while (TRUE)</a>
<a name="924">    {</a>
<a name="925">        enum Lex<a name="searched">Token</a> <a name="searched">Token</a> = (enum Lex<a name="searched">Token</a>)*(unsigned char *)<a href="lex_c.html#921">Parser</a>-&gtPos;</a>
<a name="926">        if (<a href="lex_c.html#925">Token</a> == TokenEndOfLine || <a href="lex_c.html#925">Token</a> == TokenEOF)</a>
<a name="927">            return;</a>
<a name="928">        else</a>
<a name="929">            <a href="lex_c.html#626">LexGetRawToken</a>(<a href="lex_c.html#921">Parser</a>, NULL, TRUE);</a>
<a name="930">    }</a>
<a name="931">}</a>
<a name="932"></a>
<a name="933">/* copy the tokens from StartParser to EndParser into new memory, removing TokenEOFs and terminate with a TokenEndOfFunction */</a>
<a name="934">void *<a name="searched">LexCopyTokens</a>(struct ParseState *<a name="searched">StartParser</a>, struct ParseState *<a name="searched">EndParser</a>)</a>
<a name="935">{</a>
<a name="936">    int <a name="searched">MemSize</a> = 0;</a>
<a name="937">    int <a name="searched">CopySize</a>;</a>
<a name="938">    unsigned char *<a name="searched">Pos</a> = (unsigned char *)<a href="lex_c.html#934">StartParser</a>-&gt<a name="searched">Pos</a>;</a>
<a name="939">    unsigned char *<a name="searched">NewTokens</a>;</a>
<a name="940">    unsigned char *<a name="searched">NewTokenPos</a>;</a>
<a name="941">    struct TokenLine *<a name="searched">ILine</a>;</a>
<a name="942">    Picoc *<a name="searched">pc</a> = <a href="lex_c.html#934">StartParser</a>-&gt<a name="searched">pc</a>;</a>
<a name="943">    </a>
<a name="944">    if (<a href="lex_c.html#942">pc</a>-&gtInteractiveHead == NULL)</a>
<a name="945">    { </a>
<a name="946">        /* non-interactive mode - copy the tokens */</a>
<a name="947">        <a href="lex_c.html#936">MemSize</a> = <a href="lex_c.html#934">EndParser</a>-&gtPos - <a href="lex_c.html#934">StartParser</a>-&gtPos;</a>
<a name="948">        <a href="lex_c.html#939">NewTokens</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="lex_c.html#942">pc</a>, <a href="lex_c.html#934">StartParser</a>, <a href="lex_c.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);</a>
<a name="949">        memcpy(<a href="lex_c.html#939">NewTokens</a>, (void *)<a href="lex_c.html#934">StartParser</a>-&gtPos, <a href="lex_c.html#936">MemSize</a>);</a>
<a name="950">    }</a>
<a name="951">    else</a>
<a name="952">    { </a>
<a name="953">        /* we're in interactive mode - add up line by line */</a>
<a name="954">        for (<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#942">pc</a>-&gtInteractiveHead; <a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine != NULL && (<a href="lex_c.html#938">Pos</a> &lt &<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtTokens[0] || <a href="lex_c.html#938">Pos</a> &gt= &<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes]); <a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine = <a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNext)</a>
<a name="955">        {} /* find the line we just counted */</a>
<a name="956">        </a>
<a name="957">        if (<a href="lex_c.html#934">EndParser</a>-&gtPos &gt= <a href="lex_c.html#934">StartParser</a>-&gtPos && <a href="lex_c.html#934">EndParser</a>-&gtPos &lt &<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes])</a>
<a name="958">        { </a>
<a name="959">            /* all on a single line */</a>
<a name="960">            <a href="lex_c.html#936">MemSize</a> = <a href="lex_c.html#934">EndParser</a>-&gtPos - <a href="lex_c.html#934">StartParser</a>-&gtPos;</a>
<a name="961">            <a href="lex_c.html#939">NewTokens</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="lex_c.html#942">pc</a>, <a href="lex_c.html#934">StartParser</a>, <a href="lex_c.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);</a>
<a name="962">            memcpy(<a href="lex_c.html#939">NewTokens</a>, (void *)<a href="lex_c.html#934">StartParser</a>-&gtPos, <a href="lex_c.html#936">MemSize</a>);</a>
<a name="963">        }</a>
<a name="964">        else</a>
<a name="965">        { </a>
<a name="966">            /* it's spread across multiple lines */</a>
<a name="967">            <a href="lex_c.html#936">MemSize</a> = &<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes-TOKEN_DATA_OFFSET] - <a href="lex_c.html#938">Pos</a>;</a>
<a name="968"></a>
<a name="969">            for (<a href="lex_c.html#941">ILine</a> = <a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNext; <a href="lex_c.html#941">ILine</a> != NULL && (<a href="lex_c.html#934">EndParser</a>-&gtPos &lt &<a href="lex_c.html#941">ILine</a>-&gtTokens[0] || <a href="lex_c.html#934">EndParser</a>-&gtPos &gt= &<a href="lex_c.html#941">ILine</a>-&gtTokens[<a href="lex_c.html#941">ILine</a>-&gtNumBytes]); <a href="lex_c.html#941">ILine</a> = <a href="lex_c.html#941">ILine</a>-&gtNext)</a>
<a name="970">                <a href="lex_c.html#936">MemSize</a> += <a href="lex_c.html#941">ILine</a>-&gtNumBytes - TOKEN_DATA_OFFSET;</a>
<a name="971">            </a>
<a name="972">            assert(<a href="lex_c.html#941">ILine</a> != NULL);</a>
<a name="973">            <a href="lex_c.html#936">MemSize</a> += <a href="lex_c.html#934">EndParser</a>-&gtPos - &<a href="lex_c.html#941">ILine</a>-&gtTokens[0];</a>
<a name="974">            <a href="lex_c.html#939">NewTokens</a> = <a href="variable_c.html#68">VariableAlloc</a>(<a href="lex_c.html#942">pc</a>, <a href="lex_c.html#934">StartParser</a>, <a href="lex_c.html#936">MemSize</a> + TOKEN_DATA_OFFSET, TRUE);</a>
<a name="975">            </a>
<a name="976">            <a href="lex_c.html#937">CopySize</a> = &<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtTokens[<a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNumBytes-TOKEN_DATA_OFFSET] - <a href="lex_c.html#938">Pos</a>;</a>
<a name="977">            memcpy(<a href="lex_c.html#939">NewTokens</a>, <a href="lex_c.html#938">Pos</a>, <a href="lex_c.html#937">CopySize</a>);</a>
<a name="978">            <a href="lex_c.html#940">NewTokenPos</a> = <a href="lex_c.html#939">NewTokens</a> + <a href="lex_c.html#937">CopySize</a>;</a>
<a name="979">            for (<a href="lex_c.html#941">ILine</a> = <a href="lex_c.html#942">pc</a>-&gtInteractiveCurrentLine-&gtNext; <a href="lex_c.html#941">ILine</a> != NULL && (<a href="lex_c.html#934">EndParser</a>-&gtPos &lt &<a href="lex_c.html#941">ILine</a>-&gtTokens[0] || <a href="lex_c.html#934">EndParser</a>-&gtPos &gt= &<a href="lex_c.html#941">ILine</a>-&gtTokens[<a href="lex_c.html#941">ILine</a>-&gtNumBytes]); <a href="lex_c.html#941">ILine</a> = <a href="lex_c.html#941">ILine</a>-&gtNext)</a>
<a name="980">            {</a>
<a name="981">                memcpy(<a href="lex_c.html#940">NewTokenPos</a>, &<a href="lex_c.html#941">ILine</a>-&gtTokens[0], <a href="lex_c.html#941">ILine</a>-&gtNumBytes - TOKEN_DATA_OFFSET);</a>
<a name="982">                <a href="lex_c.html#940">NewTokenPos</a> += <a href="lex_c.html#941">ILine</a>-&gtNumBytes-TOKEN_DATA_OFFSET;</a>
<a name="983">            }</a>
<a name="984">            assert(<a href="lex_c.html#941">ILine</a> != NULL);</a>
<a name="985">            memcpy(<a href="lex_c.html#940">NewTokenPos</a>, &<a href="lex_c.html#941">ILine</a>-&gtTokens[0], <a href="lex_c.html#934">EndParser</a>-&gtPos - &<a href="lex_c.html#941">ILine</a>-&gtTokens[0]);</a>
<a name="986">        }</a>
<a name="987">    }</a>
<a name="988">    </a>
<a name="989">    <a href="lex_c.html#939">NewTokens</a>[<a href="lex_c.html#936">MemSize</a>] = (unsigned char)TokenEndOfFunction;</a>
<a name="990">        </a>
<a name="991">    return <a href="lex_c.html#939">NewTokens</a>;</a>
<a name="992">}</a>
<a name="993"></a>
<a name="994">/* indicate that we've completed up to this point in the interactive input and free expired tokens */</a>
<a name="995">void <a name="searched">LexInteractiveClear</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>)</a>
<a name="996">{</a>
<a name="997">    while (<a href="lex_c.html#995">pc</a>-&gtInteractiveHead != NULL)</a>
<a name="998">    {</a>
<a name="999">        struct TokenLine *<a name="searched">NextLine</a> = <a href="lex_c.html#995">pc</a>-&gtInteractiveHead-&gtNext;</a>
<a name="1000">        </a>
<a name="1001">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="lex_c.html#995">pc</a>, <a href="lex_c.html#995">pc</a>-&gtInteractiveHead-&gtTokens);</a>
<a name="1002">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="lex_c.html#995">pc</a>, <a href="lex_c.html#995">pc</a>-&gtInteractiveHead);</a>
<a name="1003">        <a href="lex_c.html#995">pc</a>-&gtInteractiveHead = <a href="lex_c.html#999">NextLine</a>;</a>
<a name="1004">    }</a>
<a name="1005"></a>
<a name="1006">    if (<a href="lex_c.html#995">Parser</a> != NULL)</a>
<a name="1007">        <a href="lex_c.html#995">Parser</a>-&gtPos = NULL;</a>
<a name="1008">        </a>
<a name="1009">    <a href="lex_c.html#995">pc</a>-&gtInteractiveTail = NULL;</a>
<a name="1010">}</a>
<a name="1011"></a>
<a name="1012">/* indicate that we've completed up to this point in the interactive input and free expired tokens */</a>
<a name="1013">void <a name="searched">LexInteractiveCompleted</a>(Picoc *<a name="searched">pc</a>, struct ParseState *<a name="searched">Parser</a>)</a>
<a name="1014">{</a>
<a name="1015">    while (<a href="lex_c.html#1013">pc</a>-&gtInteractiveHead != NULL && !(<a href="lex_c.html#1013">Parser</a>-&gtPos &gt= &<a href="lex_c.html#1013">pc</a>-&gtInteractiveHead-&gtTokens[0] && <a href="lex_c.html#1013">Parser</a>-&gtPos &lt &<a href="lex_c.html#1013">pc</a>-&gtInteractiveHead-&gtTokens[<a href="lex_c.html#1013">pc</a>-&gtInteractiveHead-&gtNumBytes]))</a>
<a name="1016">    { </a>
<a name="1017">        /* this token line is no longer needed - free it */</a>
<a name="1018">        struct TokenLine *<a name="searched">NextLine</a> = <a href="lex_c.html#1013">pc</a>-&gtInteractiveHead-&gtNext;</a>
<a name="1019">        </a>
<a name="1020">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="lex_c.html#1013">pc</a>, <a href="lex_c.html#1013">pc</a>-&gtInteractiveHead-&gtTokens);</a>
<a name="1021">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="lex_c.html#1013">pc</a>, <a href="lex_c.html#1013">pc</a>-&gtInteractiveHead);</a>
<a name="1022">        <a href="lex_c.html#1013">pc</a>-&gtInteractiveHead = <a href="lex_c.html#1018">NextLine</a>;</a>
<a name="1023">        </a>
<a name="1024">        if (<a href="lex_c.html#1013">pc</a>-&gtInteractiveHead == NULL)</a>
<a name="1025">        { </a>
<a name="1026">            /* we've emptied the list */</a>
<a name="1027">            <a href="lex_c.html#1013">Parser</a>-&gtPos = NULL;</a>
<a name="1028">            <a href="lex_c.html#1013">pc</a>-&gtInteractiveTail = NULL;</a>
<a name="1029">        }</a>
<a name="1030">    }</a>
<a name="1031">}</a>
<a name="1032"></a>
<a name="1033">/* the next time we prompt, make it the full statement prompt */</a>
<a name="1034">void <a name="searched">LexInteractiveStatementPrompt</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="1035">{</a>
<a name="1036">    <a href="lex_c.html#1034">pc</a>-&gtLexUseStatementPrompt = TRUE;</a>
<a name="1037">}</a>
</pre></body></html>