<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head>
<body><pre><a name="1">/* picoc mini standard C library - provides an optional tiny C standard library </a>
<a name="2"> * if BUILTIN_MINI_STDLIB is defined */ </a>
<a name="3"> </a>
<a name="4">#include "picoc.h"</a>
<a name="5">#include "interpreter.h"</a>
<a name="6"></a>
<a name="7"></a>
<a name="8">/* endian-ness checking */</a>
<a name="9">static const int <a name="searched">__ENDIAN_CHECK__</a> = 1;</a>
<a name="10">static int <a name="searched">BigEndian</a>;</a>
<a name="11">static int <a name="searched">LittleEndian</a>;</a>
<a name="12"></a>
<a name="13"></a>
<a name="14">/* global initialisation for libraries */</a>
<a name="15">void <a name="searched">LibraryInit</a>(Picoc *<a name="searched">pc</a>)</a>
<a name="16">{</a>
<a name="17">    </a>
<a name="18">    /* define the version number macro */</a>
<a name="19">    <a href="clibrary_c.html#15">pc</a>-&gtVersionString = <a href="table_c.html#166">TableStrRegister</a>(<a href="clibrary_c.html#15">pc</a>, PICOC_VERSION);</a>
<a name="20">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(<a href="clibrary_c.html#15">pc</a>, NULL, "PICOC_VERSION", <a href="clibrary_c.html#15">pc</a>-&gtCharPtrType, (union AnyValue *)&<a href="clibrary_c.html#15">pc</a>-&gtVersionString, FALSE);</a>
<a name="21"></a>
<a name="22">    /* define endian-ness macros */</a>
<a name="23">    <a href="clibrary_c.html#10">BigEndian</a> = ((*(char*)&<a href="clibrary_c.html#9">__ENDIAN_CHECK__</a>) == 0);</a>
<a name="24">    <a href="clibrary_c.html#11">LittleEndian</a> = ((*(char*)&<a href="clibrary_c.html#9">__ENDIAN_CHECK__</a>) == 1);</a>
<a name="25"></a>
<a name="26">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(<a href="clibrary_c.html#15">pc</a>, NULL, "BIG_ENDIAN", &<a href="clibrary_c.html#15">pc</a>-&gtIntType, (union AnyValue *)&<a href="clibrary_c.html#10">BigEndian</a>, FALSE);</a>
<a name="27">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(<a href="clibrary_c.html#15">pc</a>, NULL, "LITTLE_ENDIAN", &<a href="clibrary_c.html#15">pc</a>-&gtIntType, (union AnyValue *)&<a href="clibrary_c.html#11">LittleEndian</a>, FALSE);</a>
<a name="28">}</a>
<a name="29"></a>
<a name="30">/* add a library */</a>
<a name="31">void <a name="searched">LibraryAdd</a>(Picoc *<a name="searched">pc</a>, struct Table *<a name="searched">GlobalTable</a>, const char *<a name="searched">LibraryName</a>, struct LibraryFunction *<a name="searched">FuncList</a>)</a>
<a name="32">{</a>
<a name="33">    struct ParseState <a name="searched">Parser</a>;</a>
<a name="34">    int <a name="searched">Count</a>;</a>
<a name="35">    char *<a name="searched">Identifier</a>;</a>
<a name="36">    struct ValueType *<a name="searched">ReturnType</a>;</a>
<a name="37">    struct Value *<a name="searched">NewValue</a>;</a>
<a name="38">    void *<a name="searched">Tokens</a>;</a>
<a name="39">    char *<a name="searched">IntrinsicName</a> = <a href="table_c.html#166">TableStrRegister</a>(<a href="clibrary_c.html#31">pc</a>, "c library");</a>
<a name="40">    </a>
<a name="41">    /* read all the library definitions */</a>
<a name="42">    for (<a href="clibrary_c.html#34">Count</a> = 0; <a href="clibrary_c.html#31">FuncList</a>[<a href="clibrary_c.html#34">Count</a>].Prototype != NULL; <a href="clibrary_c.html#34">Count</a>++)</a>
<a name="43">    {</a>
<a name="44">        <a href="clibrary_c.html#38">Tokens</a> = <a href="lex_c.html#593">LexAnalyse</a>(<a href="clibrary_c.html#31">pc</a>, <a href="clibrary_c.html#39">IntrinsicName</a>, <a href="clibrary_c.html#31">FuncList</a>[<a href="clibrary_c.html#34">Count</a>].Prototype, strlen((char *)<a href="clibrary_c.html#31">FuncList</a>[<a href="clibrary_c.html#34">Count</a>].Prototype), NULL);</a>
<a name="45">        <a href="lex_c.html#610">LexInitParser</a>(&<a href="clibrary_c.html#33">Parser</a>, <a href="clibrary_c.html#31">pc</a>, <a href="clibrary_c.html#31">FuncList</a>[<a href="clibrary_c.html#34">Count</a>].Prototype, <a href="clibrary_c.html#38">Tokens</a>, <a href="clibrary_c.html#39">IntrinsicName</a>, TRUE, FALSE);</a>
<a name="46">        <a href="type_c.html#526">TypeParse</a>(&<a href="clibrary_c.html#33">Parser</a>, &<a href="clibrary_c.html#36">ReturnType</a>, &<a href="clibrary_c.html#35">Identifier</a>, NULL);</a>
<a name="47">        <a href="clibrary_c.html#37">NewValue</a> = <a href="parse_c.html#59">ParseFunctionDefinition</a>(&<a href="clibrary_c.html#33">Parser</a>, <a href="clibrary_c.html#36">ReturnType</a>, <a href="clibrary_c.html#35">Identifier</a>);</a>
<a name="48">        <a href="clibrary_c.html#37">NewValue</a>-&gtVal-&gtFuncDef.Intrinsic = <a href="clibrary_c.html#31">FuncList</a>[<a href="clibrary_c.html#34">Count</a>].Func;</a>
<a name="49">        <a href="heap_c.html#226">HeapFreeMem</a>(<a href="clibrary_c.html#31">pc</a>, <a href="clibrary_c.html#38">Tokens</a>);</a>
<a name="50">    }</a>
<a name="51">}</a>
<a name="52"></a>
<a name="53">/* print a type to a stream without using printf/sprintf */</a>
<a name="54">void Print<a name="searched">Typ</a>e(struct Value<a name="searched">Typ</a>e *<a name="searched">Typ</a>, IOFILE *<a name="searched">Stream</a>)</a>
<a name="55">{</a>
<a name="56">    switch (<a href="clibrary_c.html#54">Typ</a>-&gtBase)</a>
<a name="57">    {</a>
<a name="58">        case TypeVoid:          <a href="stdio_c.html#729">PrintStr</a>("void", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="59">        case TypeInt:           <a href="stdio_c.html#729">PrintStr</a>("int", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="60">        case TypeShort:         <a href="stdio_c.html#729">PrintStr</a>("short", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="61">        case TypeChar:          <a href="stdio_c.html#729">PrintStr</a>("char", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="62">        case TypeLong:          <a href="stdio_c.html#729">PrintStr</a>("long", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="63">        case TypeUnsignedInt:   <a href="stdio_c.html#729">PrintStr</a>("unsigned int", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="64">        case TypeUnsignedShort: <a href="stdio_c.html#729">PrintStr</a>("unsigned short", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="65">        case TypeUnsignedLong:  <a href="stdio_c.html#729">PrintStr</a>("unsigned long", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="66">        case TypeUnsignedChar:  <a href="stdio_c.html#729">PrintStr</a>("unsigned char", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="67">#ifndef NO_FP</a>
<a name="68">        case TypeFP:            <a href="stdio_c.html#729">PrintStr</a>("double", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="69">#endif</a>
<a name="70">        case TypeFunction:      <a href="stdio_c.html#729">PrintStr</a>("function", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="71">        case TypeMacro:         <a href="stdio_c.html#729">PrintStr</a>("macro", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="72">        case TypePointer:       if (<a href="clibrary_c.html#54">Typ</a>-&gtFromType) <a href="clibrary_c.html#54">PrintType</a>(<a href="clibrary_c.html#54">Typ</a>-&gtFromType, <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#719">PrintCh</a>('*', <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="73">        case TypeArray:         <a href="clibrary_c.html#54">PrintType</a>(<a href="clibrary_c.html#54">Typ</a>-&gtFromType, <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#719">PrintCh</a>('[', <a href="clibrary_c.html#54">Stream</a>); if (<a href="clibrary_c.html#54">Typ</a>-&gtArraySize != 0) <a href="stdio_c.html#724">PrintSimpleInt</a>(<a href="clibrary_c.html#54">Typ</a>-&gtArraySize, <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#719">PrintCh</a>(']', <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="74">        case TypeStruct:        <a href="stdio_c.html#729">PrintStr</a>("struct ", <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#729">PrintStr</a>( <a href="clibrary_c.html#54">Typ</a>-&gtIdentifier, <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="75">        case TypeUnion:         <a href="stdio_c.html#729">PrintStr</a>("union ", <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#729">PrintStr</a>(<a href="clibrary_c.html#54">Typ</a>-&gtIdentifier, <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="76">        case TypeEnum:          <a href="stdio_c.html#729">PrintStr</a>("enum ", <a href="clibrary_c.html#54">Stream</a>); <a href="stdio_c.html#729">PrintStr</a>(<a href="clibrary_c.html#54">Typ</a>-&gtIdentifier, <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="77">        case TypeGotoLabel:     <a href="stdio_c.html#729">PrintStr</a>("goto label ", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="78">        case Type_Type:         <a href="stdio_c.html#729">PrintStr</a>("type ", <a href="clibrary_c.html#54">Stream</a>); break;</a>
<a name="79">    }</a>
<a name="80">}</a>
<a name="81"></a>
<a name="82"></a>
<a name="83">#ifdef BUILTIN_MINI_STDLIB</a>
<a name="84"></a>
<a name="85">/* </a>
<a name="86"> * This is a simplified standard library for small embedded systems. It doesn't require</a>
<a name="87"> * a system stdio library to operate.</a>
<a name="88"> *</a>
<a name="89"> * A more complete standard library for larger computers is in the library_XXX.c files.</a>
<a name="90"> */</a>
<a name="91"> </a>
<a name="92">static int TRUEValue = 1;</a>
<a name="93">static int <a href="unistd_c.html#10">ZeroValue</a> = 0;</a>
<a name="94"></a>
<a name="95">void <a href="stdio_c.html#46">BasicIOInit</a>(Picoc *pc)</a>
<a name="96">{</a>
<a name="97">    pc-&gtCStdOutBase.Putch = &<a href="platform_unix_c.html#76">PlatformPutc</a>;</a>
<a name="98">    pc-&gtCStdOut = &CStdOutBase;</a>
<a name="99">}</a>
<a name="100"></a>
<a name="101">/* initialise the C library */</a>
<a name="102">void CLibraryInit(Picoc *pc)</a>
<a name="103">{</a>
<a name="104">    /* define some constants */</a>
<a name="105">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(pc, NULL, "NULL", &IntType, (union AnyValue *)&<a href="unistd_c.html#10">ZeroValue</a>, FALSE);</a>
<a name="106">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(pc, NULL, "TRUE", &IntType, (union AnyValue *)&TRUEValue, FALSE);</a>
<a name="107">    <a href="variable_c.html#375">VariableDefinePlatformVar</a>(pc, NULL, "FALSE", &IntType, (union AnyValue *)&<a href="unistd_c.html#10">ZeroValue</a>, FALSE);</a>
<a name="108">}</a>
<a name="109"></a>
<a name="110">/* stream for writing into strings */</a>
<a name="111">void SPutc(unsigned char Ch, union OutputStreamInfo *Stream)</a>
<a name="112">{</a>
<a name="113">    struct StringOutputStream *Out = &Stream-&gtStr;</a>
<a name="114">    *Out-&gtWritePos++ = Ch;</a>
<a name="115">}</a>
<a name="116"></a>
<a name="117">/* print a character to a stream without using printf/sprintf */</a>
<a name="118">void <a href="stdio_c.html#719">PrintCh</a>(char OutCh, struct OutputStream *Stream)</a>
<a name="119">{</a>
<a name="120">    (*Stream-&gtPutch)(OutCh, &Stream-&gti);</a>
<a name="121">}</a>
<a name="122"></a>
<a name="123">/* print a string to a stream without using printf/sprintf */</a>
<a name="124">void <a href="stdio_c.html#729">PrintStr</a>(const char *Str, struct OutputStream *Stream)</a>
<a name="125">{</a>
<a name="126">    while (*Str != 0)</a>
<a name="127">        <a href="stdio_c.html#719">PrintCh</a>(*Str++, Stream);</a>
<a name="128">}</a>
<a name="129"></a>
<a name="130">/* print a single character a given number of times */</a>
<a name="131">void PrintRepeatedChar(Picoc *pc, char ShowChar, int Length, struct OutputStream *Stream)</a>
<a name="132">{</a>
<a name="133">    while (Length-- &gt 0)</a>
<a name="134">        <a href="stdio_c.html#719">PrintCh</a>(ShowChar, Stream);</a>
<a name="135">}</a>
<a name="136"></a>
<a name="137">/* print an unsigned integer to a stream without using printf/sprintf */</a>
<a name="138">void PrintUnsigned(unsigned long Num, unsigned int Base, int FieldWidth, int ZeroPad, int LeftJustify, struct OutputStream *Stream)</a>
<a name="139">{</a>
<a name="140">    char Result[33];</a>
<a name="141">    int ResPos = sizeof(Result);</a>
<a name="142"></a>
<a name="143">    Result[--ResPos] = '\0';</a>
<a name="144">    if (Num == 0)</a>
<a name="145">        Result[--ResPos] = '0';</a>
<a name="146">            </a>
<a name="147">    while (Num &gt 0)</a>
<a name="148">    {</a>
<a name="149">        unsigned long NextNum = Num / Base;</a>
<a name="150">        unsigned long Digit = Num - NextNum * Base;</a>
<a name="151">        if (Digit &lt 10)</a>
<a name="152">            Result[--ResPos] = '0' + Digit;</a>
<a name="153">        else</a>
<a name="154">            Result[--ResPos] = 'a' + Digit - 10;</a>
<a name="155">        </a>
<a name="156">        Num = NextNum;</a>
<a name="157">    }</a>
<a name="158">    </a>
<a name="159">    if (FieldWidth &gt 0 && !LeftJustify)</a>
<a name="160">        PrintRepeatedChar(ZeroPad ? '0' : ' ', FieldWidth - (sizeof(Result) - 1 - ResPos), Stream);</a>
<a name="161">        </a>
<a name="162">    <a href="stdio_c.html#729">PrintStr</a>(&Result[ResPos], Stream);</a>
<a name="163"></a>
<a name="164">    if (FieldWidth &gt 0 && LeftJustify)</a>
<a name="165">        PrintRepeatedChar(' ', FieldWidth - (sizeof(Result) - 1 - ResPos), Stream);</a>
<a name="166">}</a>
<a name="167"></a>
<a name="168">/* print an integer to a stream without using printf/sprintf */</a>
<a name="169">void <a href="stdio_c.html#724">PrintSimpleInt</a>(long Num, struct OutputStream *Stream)</a>
<a name="170">{</a>
<a name="171">    PrintInt(Num, -1, FALSE, FALSE, Stream);</a>
<a name="172">}</a>
<a name="173"></a>
<a name="174">/* print an integer to a stream without using printf/sprintf */</a>
<a name="175">void PrintInt(long Num, int FieldWidth, int ZeroPad, int LeftJustify, struct OutputStream *Stream)</a>
<a name="176">{</a>
<a name="177">    if (Num &lt 0)</a>
<a name="178">    {</a>
<a name="179">        <a href="stdio_c.html#719">PrintCh</a>('-', Stream);</a>
<a name="180">        Num = -Num;</a>
<a name="181">        if (FieldWidth != 0)</a>
<a name="182">            FieldWidth--;</a>
<a name="183">    }</a>
<a name="184">    </a>
<a name="185">    PrintUnsigned((unsigned long)Num, 10, FieldWidth, ZeroPad, LeftJustify, Stream);</a>
<a name="186">}</a>
<a name="187"></a>
<a name="188">#ifndef NO_FP</a>
<a name="189">/* print a double to a stream without using printf/sprintf */</a>
<a name="190">void <a href="stdio_c.html#734">PrintFP</a>(double Num, struct OutputStream *Stream)</a>
<a name="191">{</a>
<a name="192">    int Exponent = 0;</a>
<a name="193">    int MaxDecimal;</a>
<a name="194">    </a>
<a name="195">    if (Num &lt 0)</a>
<a name="196">    {</a>
<a name="197">        <a href="stdio_c.html#719">PrintCh</a>('-', Stream);</a>
<a name="198">        Num = -Num;    </a>
<a name="199">    }</a>
<a name="200">    </a>
<a name="201">    if (Num &gt= 1e7)</a>
<a name="202">        Exponent = log10(Num);</a>
<a name="203">    else if (Num &lt= 1e-7 && Num != 0.0)</a>
<a name="204">        Exponent = log10(Num) - 0.999999999;</a>
<a name="205">    </a>
<a name="206">    Num /= pow(10.0, Exponent);    </a>
<a name="207">    PrintInt((long)Num, 0, FALSE, FALSE, Stream);</a>
<a name="208">    <a href="stdio_c.html#719">PrintCh</a>('.', Stream);</a>
<a name="209">    Num = (Num - (long)Num) * 10;</a>
<a name="210">    if (abs(Num) &gt= 1e-7)</a>
<a name="211">    {</a>
<a name="212">        for (MaxDecimal = 6; MaxDecimal &gt 0 && abs(Num) &gt= 1e-7; Num = (Num - (long)(Num + 1e-7)) * 10, MaxDecimal--)</a>
<a name="213">            <a href="stdio_c.html#719">PrintCh</a>('0' + (long)(Num + 1e-7), Stream);</a>
<a name="214">    }</a>
<a name="215">    else</a>
<a name="216">        <a href="stdio_c.html#719">PrintCh</a>('0', Stream);</a>
<a name="217">        </a>
<a name="218">    if (Exponent != 0)</a>
<a name="219">    {</a>
<a name="220">        <a href="stdio_c.html#719">PrintCh</a>('e', Stream);</a>
<a name="221">        PrintInt(Exponent, 0, FALSE, FALSE, Stream);</a>
<a name="222">    }</a>
<a name="223">}</a>
<a name="224">#endif</a>
<a name="225"></a>
<a name="226">/* intrinsic functions made available to the language */</a>
<a name="227">void GenericPrintf(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs, struct OutputStream *Stream)</a>
<a name="228">{</a>
<a name="229">    char *FPos;</a>
<a name="230">    struct Value *NextArg = Param[0];</a>
<a name="231">    struct ValueType *FormatType;</a>
<a name="232">    int ArgCount = 1;</a>
<a name="233">    int LeftJustify = FALSE;</a>
<a name="234">    int ZeroPad = FALSE;</a>
<a name="235">    int FieldWidth = 0;</a>
<a name="236">    char *Format = Param[0]-&gtVal-&gtPointer;</a>
<a name="237">    </a>
<a name="238">    for (FPos = Format; *FPos != '\0'; FPos++)</a>
<a name="239">    {</a>
<a name="240">        if (*FPos == '%')</a>
<a name="241">        {</a>
<a name="242">            FPos++;</a>
<a name="243">	    FieldWidth = 0;</a>
<a name="244">            if (*FPos == '-')</a>
<a name="245">            {</a>
<a name="246">                /* a leading '-' means left justify */</a>
<a name="247">                LeftJustify = TRUE;</a>
<a name="248">                FPos++;</a>
<a name="249">            }</a>
<a name="250">            </a>
<a name="251">            if (*FPos == '0')</a>
<a name="252">            {</a>
<a name="253">                /* a leading zero means zero pad a decimal number */</a>
<a name="254">                ZeroPad = TRUE;</a>
<a name="255">                FPos++;</a>
<a name="256">            }</a>
<a name="257">            </a>
<a name="258">            /* get any field width in the format */</a>
<a name="259">            while (isdigit((int)*FPos))</a>
<a name="260">                FieldWidth = FieldWidth * 10 + (*FPos++ - '0');</a>
<a name="261">            </a>
<a name="262">            /* now check the format type */</a>
<a name="263">            switch (*FPos)</a>
<a name="264">            {</a>
<a name="265">                case 's': FormatType = CharPtrType; break;</a>
<a name="266">                case 'd': case 'u': case 'x': case 'b': case 'c': FormatType = &IntType; break;</a>
<a name="267">#ifndef NO_FP</a>
<a name="268">                case 'f': FormatType = &FPType; break;</a>
<a name="269">#endif</a>
<a name="270">                case '%': <a href="stdio_c.html#719">PrintCh</a>('%', Stream); FormatType = NULL; break;</a>
<a name="271">                case '\0': FPos--; FormatType = NULL; break;</a>
<a name="272">                default:  <a href="stdio_c.html#719">PrintCh</a>(*FPos, Stream); FormatType = NULL; break;</a>
<a name="273">            }</a>
<a name="274">            </a>
<a name="275">            if (FormatType != NULL)</a>
<a name="276">            { </a>
<a name="277">                /* we have to format something */</a>
<a name="278">                if (ArgCount &gt= NumArgs)</a>
<a name="279">                    <a href="stdio_c.html#729">PrintStr</a>("XXX", Stream);   /* not enough parameters for format */</a>
<a name="280">                else</a>
<a name="281">                {</a>
<a name="282">                    NextArg = (struct Value *)((char *)NextArg + MEM_ALIGN(sizeof(struct Value) + <a href="type_c.html#60">TypeStackSizeValue</a>(NextArg)));</a>
<a name="283">                    if (NextArg-&gtTyp != FormatType && </a>
<a name="284">                            !((FormatType == &IntType || *FPos == 'f') && IS_NUMERIC_COERCIBLE(NextArg)) &&</a>
<a name="285">                            !(FormatType == CharPtrType && (NextArg-&gtTyp-&gtBase == TypePointer || </a>
<a name="286">                                                             (NextArg-&gtTyp-&gtBase == TypeArray && NextArg-&gtTyp-&gtFromType-&gtBase == TypeChar) ) ) )</a>
<a name="287">                        <a href="stdio_c.html#729">PrintStr</a>("XXX", Stream);   /* bad type for format */</a>
<a name="288">                    else</a>
<a name="289">                    {</a>
<a name="290">                        switch (*FPos)</a>
<a name="291">                        {</a>
<a name="292">                            case 's':</a>
<a name="293">                            {</a>
<a name="294">                                char *Str;</a>
<a name="295">                                </a>
<a name="296">                                if (NextArg-&gtTyp-&gtBase == TypePointer)</a>
<a name="297">                                    Str = NextArg-&gtVal-&gtPointer;</a>
<a name="298">                                else</a>
<a name="299">                                    Str = &NextArg-&gtVal-&gtArrayMem[0];</a>
<a name="300">                                    </a>
<a name="301">                                if (Str == NULL)</a>
<a name="302">                                    <a href="stdio_c.html#729">PrintStr</a>("NULL", Stream); </a>
<a name="303">                                else</a>
<a name="304">                                    <a href="stdio_c.html#729">PrintStr</a>(Str, Stream); </a>
<a name="305">                                break;</a>
<a name="306">                            }</a>
<a name="307">                            case 'd': PrintInt(<a href="expression_c.html#164">ExpressionCoerceInteger</a>(NextArg), FieldWidth, ZeroPad, LeftJustify, Stream); break;</a>
<a name="308">                            case 'u': PrintUnsigned(<a href="expression_c.html#184">ExpressionCoerceUnsignedInteger</a>(NextArg), 10, FieldWidth, ZeroPad, LeftJustify, Stream); break;</a>
<a name="309">                            case 'x': PrintUnsigned(<a href="expression_c.html#184">ExpressionCoerceUnsignedInteger</a>(NextArg), 16, FieldWidth, ZeroPad, LeftJustify, Stream); break;</a>
<a name="310">                            case 'b': PrintUnsigned(<a href="expression_c.html#184">ExpressionCoerceUnsignedInteger</a>(NextArg), 2, FieldWidth, ZeroPad, LeftJustify, Stream); break;</a>
<a name="311">                            case 'c': <a href="stdio_c.html#719">PrintCh</a>(<a href="expression_c.html#184">ExpressionCoerceUnsignedInteger</a>(NextArg), Stream); break;</a>
<a name="312">#ifndef NO_FP</a>
<a name="313">                            case 'f': <a href="stdio_c.html#734">PrintFP</a>(<a href="expression_c.html#205">ExpressionCoerceFP</a>(NextArg), Stream); break;</a>
<a name="314">#endif</a>
<a name="315">                        }</a>
<a name="316">                    }</a>
<a name="317">                }</a>
<a name="318">                </a>
<a name="319">                ArgCount++;</a>
<a name="320">            }</a>
<a name="321">        }</a>
<a name="322">        else</a>
<a name="323">            <a href="stdio_c.html#719">PrintCh</a>(*FPos, Stream);</a>
<a name="324">    }</a>
<a name="325">}</a>
<a name="326"></a>
<a name="327">/* printf(): print to console output */</a>
<a name="328">void LibPrintf(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="329">{</a>
<a name="330">    struct OutputStream ConsoleStream;</a>
<a name="331">    </a>
<a name="332">    ConsoleStream.Putch = &<a href="platform_unix_c.html#76">PlatformPutc</a>;</a>
<a name="333">    GenericPrintf(Parser, ReturnValue, Param, NumArgs, &ConsoleStream);</a>
<a name="334">}</a>
<a name="335"></a>
<a name="336">/* sprintf(): print to a string */</a>
<a name="337">void LibSPrintf(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="338">{</a>
<a name="339">    struct OutputStream StrStream;</a>
<a name="340">    </a>
<a name="341">    StrStream.Putch = &SPutc;</a>
<a name="342">    StrStream.i.Str.Parser = Parser;</a>
<a name="343">    StrStream.i.Str.WritePos = Param[0]-&gtVal-&gtPointer;</a>
<a name="344"></a>
<a name="345">    GenericPrintf(Parser, ReturnValue, Param+1, NumArgs-1, &StrStream);</a>
<a name="346">    <a href="stdio_c.html#719">PrintCh</a>(0, &StrStream);</a>
<a name="347">    ReturnValue-&gtVal-&gtPointer = *Param;</a>
<a name="348">}</a>
<a name="349"></a>
<a name="350">/* get a line of input. protected from buffer overrun */</a>
<a name="351">void LibGets(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="352">{</a>
<a name="353">    ReturnValue-&gtVal-&gtPointer = <a href="platform_unix_c.html#39">PlatformGetLine</a>(Param[0]-&gtVal-&gtPointer, GETS_BUF_MAX, NULL);</a>
<a name="354">    if (ReturnValue-&gtVal-&gtPointer != NULL)</a>
<a name="355">    {</a>
<a name="356">        char *EOLPos = strchr(Param[0]-&gtVal-&gtPointer, '\n');</a>
<a name="357">        if (EOLPos != NULL)</a>
<a name="358">            *EOLPos = '\0';</a>
<a name="359">    }</a>
<a name="360">}</a>
<a name="361"></a>
<a name="362">void LibGetc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="363">{</a>
<a name="364">    ReturnValue-&gtVal-&gtInteger = <a href="platform_unix_c.html#69">PlatformGetCharacter</a>();</a>
<a name="365">}</a>
<a name="366"></a>
<a name="367">void LibExit(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="368">{</a>
<a name="369">    <a href="platform_unix_c.html#135">PlatformExit</a>(Param[0]-&gtVal-&gtInteger);</a>
<a name="370">}</a>
<a name="371"></a>
<a name="372">#ifdef PICOC_LIBRARY</a>
<a name="373">void LibSin(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="374">{</a>
<a name="375">    ReturnValue-&gtVal-&gtFP = sin(Param[0]-&gtVal-&gtFP);</a>
<a name="376">}</a>
<a name="377"></a>
<a name="378">void LibCos(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="379">{</a>
<a name="380">    ReturnValue-&gtVal-&gtFP = cos(Param[0]-&gtVal-&gtFP);</a>
<a name="381">}</a>
<a name="382"></a>
<a name="383">void LibTan(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="384">{</a>
<a name="385">    ReturnValue-&gtVal-&gtFP = tan(Param[0]-&gtVal-&gtFP);</a>
<a name="386">}</a>
<a name="387"></a>
<a name="388">void LibAsin(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="389">{</a>
<a name="390">    ReturnValue-&gtVal-&gtFP = asin(Param[0]-&gtVal-&gtFP);</a>
<a name="391">}</a>
<a name="392"></a>
<a name="393">void LibAcos(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="394">{</a>
<a name="395">    ReturnValue-&gtVal-&gtFP = acos(Param[0]-&gtVal-&gtFP);</a>
<a name="396">}</a>
<a name="397"></a>
<a name="398">void LibAtan(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="399">{</a>
<a name="400">    ReturnValue-&gtVal-&gtFP = atan(Param[0]-&gtVal-&gtFP);</a>
<a name="401">}</a>
<a name="402"></a>
<a name="403">void LibSinh(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="404">{</a>
<a name="405">    ReturnValue-&gtVal-&gtFP = sinh(Param[0]-&gtVal-&gtFP);</a>
<a name="406">}</a>
<a name="407"></a>
<a name="408">void LibCosh(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="409">{</a>
<a name="410">    ReturnValue-&gtVal-&gtFP = cosh(Param[0]-&gtVal-&gtFP);</a>
<a name="411">}</a>
<a name="412"></a>
<a name="413">void LibTanh(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="414">{</a>
<a name="415">    ReturnValue-&gtVal-&gtFP = tanh(Param[0]-&gtVal-&gtFP);</a>
<a name="416">}</a>
<a name="417"></a>
<a name="418">void LibExp(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="419">{</a>
<a name="420">    ReturnValue-&gtVal-&gtFP = exp(Param[0]-&gtVal-&gtFP);</a>
<a name="421">}</a>
<a name="422"></a>
<a name="423">void LibFabs(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="424">{</a>
<a name="425">    ReturnValue-&gtVal-&gtFP = fabs(Param[0]-&gtVal-&gtFP);</a>
<a name="426">}</a>
<a name="427"></a>
<a name="428">void LibLog(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="429">{</a>
<a name="430">    ReturnValue-&gtVal-&gtFP = log(Param[0]-&gtVal-&gtFP);</a>
<a name="431">}</a>
<a name="432"></a>
<a name="433">void LibLog10(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="434">{</a>
<a name="435">    ReturnValue-&gtVal-&gtFP = log10(Param[0]-&gtVal-&gtFP);</a>
<a name="436">}</a>
<a name="437"></a>
<a name="438">void LibPow(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="439">{</a>
<a name="440">    ReturnValue-&gtVal-&gtFP = pow(Param[0]-&gtVal-&gtFP, Param[1]-&gtVal-&gtFP);</a>
<a name="441">}</a>
<a name="442"></a>
<a name="443">void LibSqrt(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="444">{</a>
<a name="445">    ReturnValue-&gtVal-&gtFP = sqrt(Param[0]-&gtVal-&gtFP);</a>
<a name="446">}</a>
<a name="447"></a>
<a name="448">void LibRound(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="449">{</a>
<a name="450">    ReturnValue-&gtVal-&gtFP = floor(Param[0]-&gtVal-&gtFP + 0.5);   /* XXX - fix for soft float */</a>
<a name="451">}</a>
<a name="452"></a>
<a name="453">void LibCeil(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="454">{</a>
<a name="455">    ReturnValue-&gtVal-&gtFP = ceil(Param[0]-&gtVal-&gtFP);</a>
<a name="456">}</a>
<a name="457"></a>
<a name="458">void LibFloor(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="459">{</a>
<a name="460">    ReturnValue-&gtVal-&gtFP = floor(Param[0]-&gtVal-&gtFP);</a>
<a name="461">}</a>
<a name="462">#endif</a>
<a name="463"></a>
<a name="464">#ifndef NO_STRING_FUNCTIONS</a>
<a name="465">void LibMalloc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="466">{</a>
<a name="467">    ReturnValue-&gtVal-&gtPointer = malloc(Param[0]-&gtVal-&gtInteger);</a>
<a name="468">}</a>
<a name="469"></a>
<a name="470">#ifndef NO_CALLOC</a>
<a name="471">void LibCalloc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="472">{</a>
<a name="473">    ReturnValue-&gtVal-&gtPointer = calloc(Param[0]-&gtVal-&gtInteger, Param[1]-&gtVal-&gtInteger);</a>
<a name="474">}</a>
<a name="475">#endif</a>
<a name="476"></a>
<a name="477">#ifndef NO_REALLOC</a>
<a name="478">void LibRealloc(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="479">{</a>
<a name="480">    ReturnValue-&gtVal-&gtPointer = realloc(Param[0]-&gtVal-&gtPointer, Param[1]-&gtVal-&gtInteger);</a>
<a name="481">}</a>
<a name="482">#endif</a>
<a name="483"></a>
<a name="484">void LibFree(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="485">{</a>
<a name="486">    free(Param[0]-&gtVal-&gtPointer);</a>
<a name="487">}</a>
<a name="488"></a>
<a name="489">void LibStrcpy(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="490">{</a>
<a name="491">    char *To = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="492">    char *From = (char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="493">    </a>
<a name="494">    while (*From != '\0')</a>
<a name="495">        *To++ = *From++;</a>
<a name="496">    </a>
<a name="497">    *To = '\0';</a>
<a name="498">}</a>
<a name="499"></a>
<a name="500">void LibStrncpy(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="501">{</a>
<a name="502">    char *To = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="503">    char *From = (char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="504">    int Len = Param[2]-&gtVal-&gtInteger;</a>
<a name="505">    </a>
<a name="506">    for (; *From != '\0' && Len &gt 0; Len--)</a>
<a name="507">        *To++ = *From++;</a>
<a name="508">    </a>
<a name="509">    if (Len &gt 0)</a>
<a name="510">        *To = '\0';</a>
<a name="511">}</a>
<a name="512"></a>
<a name="513">void LibStrcmp(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="514">{</a>
<a name="515">    char *Str1 = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="516">    char *Str2 = (char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="517">    int StrEnded;</a>
<a name="518">    </a>
<a name="519">    for (StrEnded = FALSE; !StrEnded; StrEnded = (*Str1 == '\0' || *Str2 == '\0'), Str1++, Str2++)</a>
<a name="520">    {</a>
<a name="521">         if (*Str1 &lt *Str2) { ReturnValue-&gtVal-&gtInteger = -1; return; } </a>
<a name="522">         else if (*Str1 &gt *Str2) { ReturnValue-&gtVal-&gtInteger = 1; return; }</a>
<a name="523">    }</a>
<a name="524">    </a>
<a name="525">    ReturnValue-&gtVal-&gtInteger = 0;</a>
<a name="526">}</a>
<a name="527"></a>
<a name="528">void LibStrncmp(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="529">{</a>
<a name="530">    char *Str1 = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="531">    char *Str2 = (char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="532">    int Len = Param[2]-&gtVal-&gtInteger;</a>
<a name="533">    int StrEnded;</a>
<a name="534">    </a>
<a name="535">    for (StrEnded = FALSE; !StrEnded && Len &gt 0; StrEnded = (*Str1 == '\0' || *Str2 == '\0'), Str1++, Str2++, Len--)</a>
<a name="536">    {</a>
<a name="537">         if (*Str1 &lt *Str2) { ReturnValue-&gtVal-&gtInteger = -1; return; } </a>
<a name="538">         else if (*Str1 &gt *Str2) { ReturnValue-&gtVal-&gtInteger = 1; return; }</a>
<a name="539">    }</a>
<a name="540">    </a>
<a name="541">    ReturnValue-&gtVal-&gtInteger = 0;</a>
<a name="542">}</a>
<a name="543"></a>
<a name="544">void LibStrcat(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="545">{</a>
<a name="546">    char *To = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="547">    char *From = (char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="548">    </a>
<a name="549">    while (*To != '\0')</a>
<a name="550">        To++;</a>
<a name="551">    </a>
<a name="552">    while (*From != '\0')</a>
<a name="553">        *To++ = *From++;</a>
<a name="554">    </a>
<a name="555">    *To = '\0';</a>
<a name="556">}</a>
<a name="557"></a>
<a name="558">void LibIndex(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="559">{</a>
<a name="560">    char *Pos = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="561">    int SearchChar = Param[1]-&gtVal-&gtInteger;</a>
<a name="562"></a>
<a name="563">    while (*Pos != '\0' && *Pos != SearchChar)</a>
<a name="564">        Pos++;</a>
<a name="565">    </a>
<a name="566">    if (*Pos != SearchChar)</a>
<a name="567">        ReturnValue-&gtVal-&gtPointer = NULL;</a>
<a name="568">    else</a>
<a name="569">        ReturnValue-&gtVal-&gtPointer = Pos;</a>
<a name="570">}</a>
<a name="571"></a>
<a name="572">void LibRindex(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="573">{</a>
<a name="574">    char *Pos = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="575">    int SearchChar = Param[1]-&gtVal-&gtInteger;</a>
<a name="576"></a>
<a name="577">    ReturnValue-&gtVal-&gtPointer = NULL;</a>
<a name="578">    for (; *Pos != '\0'; Pos++)</a>
<a name="579">    {</a>
<a name="580">        if (*Pos == SearchChar)</a>
<a name="581">            ReturnValue-&gtVal-&gtPointer = Pos;</a>
<a name="582">    }</a>
<a name="583">}</a>
<a name="584"></a>
<a name="585">void LibStrlen(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="586">{</a>
<a name="587">    char *Pos = (char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="588">    int Len;</a>
<a name="589">    </a>
<a name="590">    for (Len = 0; *Pos != '\0'; Pos++)</a>
<a name="591">        Len++;</a>
<a name="592">    </a>
<a name="593">    ReturnValue-&gtVal-&gtInteger = Len;</a>
<a name="594">}</a>
<a name="595"></a>
<a name="596">void LibMemset(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="597">{</a>
<a name="598">    /* we can use the system memset() */</a>
<a name="599">    memset(Param[0]-&gtVal-&gtPointer, Param[1]-&gtVal-&gtInteger, Param[2]-&gtVal-&gtInteger);</a>
<a name="600">}</a>
<a name="601"></a>
<a name="602">void LibMemcpy(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="603">{</a>
<a name="604">    /* we can use the system memcpy() */</a>
<a name="605">    memcpy(Param[0]-&gtVal-&gtPointer, Param[1]-&gtVal-&gtPointer, Param[2]-&gtVal-&gtInteger);</a>
<a name="606">}</a>
<a name="607"></a>
<a name="608">void LibMemcmp(struct ParseState *Parser, struct Value *ReturnValue, struct Value **Param, int NumArgs)</a>
<a name="609">{</a>
<a name="610">    unsigned char *Mem1 = (unsigned char *)Param[0]-&gtVal-&gtPointer;</a>
<a name="611">    unsigned char *Mem2 = (unsigned char *)Param[1]-&gtVal-&gtPointer;</a>
<a name="612">    int Len = Param[2]-&gtVal-&gtInteger;</a>
<a name="613">    </a>
<a name="614">    for (; Len &gt 0; Mem1++, Mem2++, Len--)</a>
<a name="615">    {</a>
<a name="616">         if (*Mem1 &lt *Mem2) { ReturnValue-&gtVal-&gtInteger = -1; return; } </a>
<a name="617">         else if (*Mem1 &gt *Mem2) { ReturnValue-&gtVal-&gtInteger = 1; return; }</a>
<a name="618">    }</a>
<a name="619">    </a>
<a name="620">    ReturnValue-&gtVal-&gtInteger = 0;</a>
<a name="621">}</a>
<a name="622">#endif</a>
<a name="623"></a>
<a name="624">/* list of all library functions and their prototypes */</a>
<a name="625">struct LibraryFunction CLibrary[] =</a>
<a name="626">{</a>
<a name="627">    { LibPrintf,        "void printf(char *, ...);" },</a>
<a name="628">    { LibSPrintf,       "char *sprintf(char *, char *, ...);" },</a>
<a name="629">    { LibGets,          "char *gets(char *);" },</a>
<a name="630">    { LibGetc,          "int getchar();" },</a>
<a name="631">    { LibExit,          "void exit(int);" },</a>
<a name="632">#ifdef PICOC_LIBRARY</a>
<a name="633">    { LibSin,           "float sin(float);" },</a>
<a name="634">    { LibCos,           "float cos(float);" },</a>
<a name="635">    { LibTan,           "float tan(float);" },</a>
<a name="636">    { LibAsin,          "float asin(float);" },</a>
<a name="637">    { LibAcos,          "float acos(float);" },</a>
<a name="638">    { LibAtan,          "float atan(float);" },</a>
<a name="639">    { LibSinh,          "float sinh(float);" },</a>
<a name="640">    { LibCosh,          "float cosh(float);" },</a>
<a name="641">    { LibTanh,          "float tanh(float);" },</a>
<a name="642">    { LibExp,           "float exp(float);" },</a>
<a name="643">    { LibFabs,          "float fabs(float);" },</a>
<a name="644">    { LibLog,           "float log(float);" },</a>
<a name="645">    { LibLog10,         "float log10(float);" },</a>
<a name="646">    { LibPow,           "float pow(float,float);" },</a>
<a name="647">    { LibSqrt,          "float sqrt(float);" },</a>
<a name="648">    { LibRound,         "float round(float);" },</a>
<a name="649">    { LibCeil,          "float ceil(float);" },</a>
<a name="650">    { LibFloor,         "float floor(float);" },</a>
<a name="651">#endif</a>
<a name="652">    { LibMalloc,        "void *malloc(int);" },</a>
<a name="653">#ifndef NO_CALLOC</a>
<a name="654">    { LibCalloc,        "void *calloc(int,int);" },</a>
<a name="655">#endif</a>
<a name="656">#ifndef NO_REALLOC</a>
<a name="657">    { LibRealloc,       "void *realloc(void *,int);" },</a>
<a name="658">#endif</a>
<a name="659">    { LibFree,          "void free(void *);" },</a>
<a name="660">#ifndef NO_STRING_FUNCTIONS</a>
<a name="661">    { LibStrcpy,        "void strcpy(char *,char *);" },</a>
<a name="662">    { LibStrncpy,       "void strncpy(char *,char *,int);" },</a>
<a name="663">    { LibStrcmp,        "int strcmp(char *,char *);" },</a>
<a name="664">    { LibStrncmp,       "int strncmp(char *,char *,int);" },</a>
<a name="665">    { LibStrcat,        "void strcat(char *,char *);" },</a>
<a name="666">    { LibIndex,         "char *index(char *,int);" },</a>
<a name="667">    { LibRindex,        "char *rindex(char *,int);" },</a>
<a name="668">    { LibStrlen,        "int strlen(char *);" },</a>
<a name="669">    { LibMemset,        "void memset(void *,int,int);" },</a>
<a name="670">    { LibMemcpy,        "void memcpy(void *,void *,int);" },</a>
<a name="671">    { LibMemcmp,        "int memcmp(void *,void *,int);" },</a>
<a name="672">#endif</a>
<a name="673">    { NULL,             NULL }</a>
<a name="674">};</a>
<a name="675"></a>
<a name="676">#endif /* BUILTIN_MINI_STDLIB */</a>
</pre></body></html>